# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/python@6.4.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer
from .._vendor import KameleoLocalApiClientMixinABC, _format_url_section

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_kameleo_local_api_get_base_profile_search_parameters_request(
    *,
    device_type: Optional[str] = None,
    os_family: Optional[str] = None,
    browser_product: Optional[str] = None,
    language: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/base-profile-search-parameters"

    # Construct parameters
    if device_type is not None:
        _params["deviceType"] = _SERIALIZER.query("device_type", device_type, "str")
    if os_family is not None:
        _params["osFamily"] = _SERIALIZER.query("os_family", os_family, "str")
    if browser_product is not None:
        _params["browserProduct"] = _SERIALIZER.query("browser_product", browser_product, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_kameleo_local_api_search_base_profiles_request(
    *,
    device_type: Optional[str] = None,
    os_family: Optional[str] = None,
    browser_product: Optional[str] = None,
    language: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/base-profiles"

    # Construct parameters
    if device_type is not None:
        _params["deviceType"] = _SERIALIZER.query("device_type", device_type, "str")
    if os_family is not None:
        _params["osFamily"] = _SERIALIZER.query("os_family", os_family, "str")
    if browser_product is not None:
        _params["browserProduct"] = _SERIALIZER.query("browser_product", browser_product, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_kameleo_local_api_list_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_add_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_delete_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_healthcheck_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/healthcheck"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_get_user_info_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/user-info"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_terminate_application_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/terminate"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_test_proxy_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/test-proxy"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_list_profiles_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_create_profile_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/new"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_update_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_read_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_delete_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_get_profile_status_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/status"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_start_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/start"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_start_profile_with_web_driver_settings_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/start"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_stop_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/stop"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_save_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/save"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_duplicate_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/duplicate"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_load_profile_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/load"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_upgrade_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/upgrade"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


class KameleoLocalApiClientOperationsMixin(KameleoLocalApiClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace
    def get_base_profile_search_parameters(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BaseProfileSearchParameters:
        """Get the possible values for base profile filtering. We can filter the available values. With
        this we can see for example that what languages of profiles do we have for Windows profiles
        with Chrome.

        Get the possible values for base profile filtering. We can filter the available values. With
        this we can see for example that what languages of profiles do we have for Windows profiles
        with Chrome.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'. For example set it to mobile if you only want to see what os families we have for
         mobile profiles. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'. For example set it to windows if you only want to see what languages
         we have for windows profiles. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'. For example set it to safari if you only want to see what os
         families we have for chrome profiles. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format. For
         example set it to en-gb if you only want to see what browser products we have for English
         profiles. Default value is None.
        :paramtype language: str
        :return: BaseProfileSearchParameters
        :rtype: ~kameleo.local_api_client.models.BaseProfileSearchParameters
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BaseProfileSearchParameters] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_base_profile_search_parameters_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("BaseProfileSearchParameters", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def search_base_profiles(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.BaseProfilePreview]:
        """Filtering base profiles with some criteria. It will return X base profiles. It is not an
        idempotent method. This means if you are calling it twice after each other it may return a
        different set of base profiles.

        Filtering base profiles with some criteria. It will return X base profiles. It is not an
        idempotent method. This means if you are calling it twice after each other it may return a
        different set of base profiles.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format.
         For example, set it to en-gb if you want to get only English profiles from Great-Britain.
         You can also use a comma-separated list to provide more than one value.
         This field also supports wildcard for the sublanguage part: to retrieve both en-us, en-gb, and
         en-ca profiles, use 'en-*' as value. Default value is None.
        :paramtype language: str
        :return: list of BaseProfilePreview
        :rtype: list[~kameleo.local_api_client.models.BaseProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BaseProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_search_base_profiles_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BaseProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_cookies(self, guid: str, **kwargs: Any) -> List[_models.BrowserCookie]:
        """Gets the list of the cookies of the profile.

        Gets the list of the cookies of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def add_cookies(
        self,
        guid: str,
        body: Optional[List[_models.CookieRequest]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_cookies(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_cookies(
        self, guid: str, body: Optional[Union[List[_models.CookieRequest], IO]] = None, **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        Adds a list of cookies to the profile. If cookies are already present for a domain, they will
        be overwritten.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a [CookieRequest] type or a IO type. Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[CookieRequest]")
            else:
                _json = None

        request = build_kameleo_local_api_add_cookies_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def delete_cookies(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes the cookies of the profile.

        Deletes the cookies of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def healthcheck(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Health check request to test if Kameleo has been started and accepting connections.

        Health check request to test if Kameleo has been started and accepting connections.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_healthcheck_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_user_info(self, **kwargs: Any) -> _models.UserInfoResponse:
        """Provides information about the user.

        Provides information about the user.

        :return: UserInfoResponse
        :rtype: ~kameleo.local_api_client.models.UserInfoResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserInfoResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_user_info_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("UserInfoResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def terminate_application(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_terminate_application_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    def test_proxy(
        self, body: Optional[_models.TestProxyRequest] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.TestProxyRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def test_proxy(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def test_proxy(
        self, body: Optional[Union[_models.TestProxyRequest, IO]] = None, **kwargs: Any
    ) -> _models.TestProxyResponse:
        """Tests a provided proxy connection.

        Tests a provided proxy connection.

        :param body: Is either a TestProxyRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.TestProxyRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: TestProxyResponse
        :rtype: ~kameleo.local_api_client.models.TestProxyResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TestProxyResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "TestProxyRequest")
            else:
                _json = None

        request = build_kameleo_local_api_test_proxy_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.TestProxyResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("TestProxyResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_profiles(self, **kwargs: Any) -> List[_models.ProfilePreview]:
        """Gets a preview list about profiles that are currently in the system.

        Gets a preview list about profiles that are currently in the system.

        :return: list of ProfilePreview
        :rtype: list[~kameleo.local_api_client.models.ProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_profiles_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create_profile(
        self,
        body: Optional[_models.CreateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_profile(
        self, body: Optional[Union[_models.CreateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected BaseProfile and inputs.

        Creates a new profile based on a selected BaseProfile and inputs.

        :param body: Is either a CreateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_create_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def update_profile(
        self,
        guid: str,
        body: Optional[_models.UpdateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_profile(
        self, guid: str, body: Optional[Union[_models.UpdateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a UpdateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_update_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def read_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Returns a profile from the system.

        Returns a profile from the system.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def delete_profile(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Removes profile from the system. When you are launching and stopping a big number of profiles
        for example for scraping it is recommended to call this after you have stopped the profile.
        This will free up disk space.

        Removes profile from the system. When you are launching and stopping a big number of profiles
        for example for scraping it is recommended to call this after you have stopped the profile.
        This will free up disk space.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_profile_status(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Returns the current status of the profile.

        Returns the current status of the profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_profile_status_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def start_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Starts a profile. The browser will be launched. In case of mobile profiles and external
        launcher types the external spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile. The browser will be launched. In case of mobile profiles and external
        launcher types the external spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_start_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def start_profile_with_web_driver_settings(
        self,
        guid: str,
        body: Optional[_models.WebDriverSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def start_profile_with_web_driver_settings(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def start_profile_with_web_driver_settings(
        self, guid: str, body: Optional[Union[_models.WebDriverSettings, IO]] = None, **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        Starts a profile, for desktop profiles additional WebDriver settings can be provided. The
        browser will be launched. In case of mobile profiles and external launcher types the external
        spoofing engine will be launched.
        If successful, the profile's lifetime state will be 'running'. Otherwise the profile's lifetime
        state will be 'terminated'. During the api call the lifetime state can be 'starting' for a
        temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a WebDriverSettings type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WebDriverSettings")
            else:
                _json = None

        request = build_kameleo_local_api_start_profile_with_web_driver_settings_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def stop_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Stops a profile. The browsers will be stopped. In case of mobile profiles and external launcher
        types the external spoofing engine will be stopped.
        If successful, the profile's lifetime state will be 'terminated'. Otherwise the profile's
        lifetime state will be 'running'. During the api call the lifetime state can be 'terminating'
        for a temporarily.

        Stops a profile. The browsers will be stopped. In case of mobile profiles and external launcher
        types the external spoofing engine will be stopped.
        If successful, the profile's lifetime state will be 'terminated'. Otherwise the profile's
        lifetime state will be 'running'. During the api call the lifetime state can be 'terminating'
        for a temporarily.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_stop_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def save_profile(
        self,
        guid: str,
        body: Optional[_models.SaveProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.SaveProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def save_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def save_profile(
        self, guid: str, body: Optional[Union[_models.SaveProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        Saves a profile to a file. It will create a .kameleo file to the given location. It will store
        all the profile settings, browsing data, cookies, history, bookmarks, installed extension /
        addons. Later it can be reloaded.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a SaveProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.SaveProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_save_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def duplicate_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Creates a duplicate of a loaded profile in memory. The created profile contains all the profile
        settings, browsing data, cookies, history, bookmarks and installed extensions. This operation
        does not perform any filesystem activity and will not affect your existing profile.

        Creates a duplicate of a loaded profile in memory. The created profile contains all the profile
        settings, browsing data, cookies, history, bookmarks and installed extensions. This operation
        does not perform any filesystem activity and will not affect your existing profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_duplicate_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def load_profile(
        self,
        body: Optional[_models.LoadProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.LoadProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def load_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def load_profile(
        self, body: Optional[Union[_models.LoadProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        Loads a profile from a file. It will load the profile from a .kameleo file. It will load all
        the profile settings, browsing data, cookies, history, bookmarks, installed extension / addons.

        :param body: Is either a LoadProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.LoadProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "LoadProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_load_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def upgrade_profile(self, guid: str, **kwargs: Any) -> Optional[_models.ProfileResponse]:
        """Upgrades the profile to the latest available browser version from the server. The exact target
        of the upgrade depends on the profile's current device, browser, operating system, and language
        settings.

        Upgrades the profile to the latest available browser version from the server. The exact target
        of the upgrade depends on the profile's current device, browser, operating system, and language
        settings.

        :param guid: Required.
        :type guid: str
        :return: ProfileResponse or None
        :rtype: ~kameleo.local_api_client.models.ProfileResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ProfileResponse]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_upgrade_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
