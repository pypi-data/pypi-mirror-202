// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: img.proto
#ifndef GRPC_img_2eproto__INCLUDED
#define GRPC_img_2eproto__INCLUDED

#include "img.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace rpc {
namespace img {

class view final {
 public:
  static constexpr char const* service_full_name() {
    return "rpc.img.view";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // create a new panel (which may or may not be immediately 
    virtual ::grpc::Status panel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::rpc::img::Id* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> Asyncpanel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(AsyncpanelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> PrepareAsyncpanel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(PrepareAsyncpanelRaw(context, request, cq));
    }
    virtual ::grpc::Status hide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynchide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynchideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynchide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynchideRaw(context, request, cq));
    }
    virtual ::grpc::Status show(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncshow(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncshowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncshow(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncshowRaw(context, request, cq));
    }
    virtual ::grpc::Status freeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncfreezeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncfreezeRaw(context, request, cq));
    }
    virtual ::grpc::Status unfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncunfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncunfreezeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncunfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncunfreezeRaw(context, request, cq));
    }
    virtual ::grpc::Status close(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncclose(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncclose(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccloseRaw(context, request, cq));
    }
    virtual ::grpc::Status release(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncrelease(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncreleaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncrelease(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncreleaseRaw(context, request, cq));
    }
    virtual ::grpc::Status axes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncaxes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncaxesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncaxes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncaxesRaw(context, request, cq));
    }
    virtual ::grpc::Status popup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncpopup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncpopupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncpopup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncpopupRaw(context, request, cq));
    }
    virtual ::grpc::Status load(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::rpc::img::Id* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> Asyncload(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(AsyncloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> PrepareAsyncload(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(PrepareAsyncloadRaw(context, request, cq));
    }
    virtual ::grpc::Status reload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncreload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncreloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncreload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncreloadRaw(context, request, cq));
    }
    virtual ::grpc::Status unload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncunload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncunloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncunload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncunloadRaw(context, request, cq));
    }
    virtual ::grpc::Status restore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::rpc::img::Id* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> Asyncrestore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(AsyncrestoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>> PrepareAsyncrestore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>>(PrepareAsyncrestoreRaw(context, request, cq));
    }
    virtual ::grpc::Status colormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccolormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccolormapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccolormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccolormapRaw(context, request, cq));
    }
    virtual ::grpc::Status colorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccolorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccolorwedgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccolorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccolorwedgeRaw(context, request, cq));
    }
    virtual ::grpc::Status datarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncdatarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdatarangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdatarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdatarangeRaw(context, request, cq));
    }
    virtual ::grpc::Status contourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccontourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccontourlevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccontourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccontourlevelsRaw(context, request, cq));
    }
    virtual ::grpc::Status contourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccontourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccontourthicknessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccontourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccontourthicknessRaw(context, request, cq));
    }
    virtual ::grpc::Status contourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccontourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccontourcolorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccontourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccontourcolorRaw(context, request, cq));
    }
    virtual ::grpc::Status channel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncchannel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncchannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncchannel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncchannelRaw(context, request, cq));
    }
    virtual ::grpc::Status zoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynczoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynczoomlevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynczoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynczoomlevelRaw(context, request, cq));
    }
    virtual ::grpc::Status zoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynczoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynczoomboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynczoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynczoomboxRaw(context, request, cq));
    }
    virtual ::grpc::Status output(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncoutput(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncoutputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncoutput(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncoutputRaw(context, request, cq));
    }
    virtual ::grpc::Status fileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::rpc::img::FileInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>> Asyncfileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>>(AsyncfileinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>> PrepareAsyncfileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>>(PrepareAsyncfileinfoRaw(context, request, cq));
    }
    virtual ::grpc::Status keyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::rpc::img::KeyInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>> Asynckeyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>>(AsynckeyinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>> PrepareAsynckeyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>>(PrepareAsynckeyinfoRaw(context, request, cq));
    }
    virtual ::grpc::Status cwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::rpc::img::Path* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>> Asynccwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>>(AsynccwdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>> PrepareAsynccwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>>(PrepareAsynccwdRaw(context, request, cq));
    }
    virtual ::grpc::Status done(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncdone(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdoneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdone(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdoneRaw(context, request, cq));
    }
    virtual ::grpc::Status interactivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::rpc::img::InteractiveMaskResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>> Asyncinteractivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>>(AsyncinteractivemaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>> PrepareAsyncinteractivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>>(PrepareAsyncinteractivemaskRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* AsyncpanelRaw(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* PrepareAsyncpanelRaw(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynchideRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynchideRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncshowRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncshowRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncunfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncunfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccloseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccloseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncreleaseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncreleaseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncaxesRaw(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncaxesRaw(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncpopupRaw(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncpopupRaw(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* AsyncloadRaw(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* PrepareAsyncloadRaw(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncreloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncreloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncunloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncunloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* AsyncrestoreRaw(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Id>* PrepareAsyncrestoreRaw(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccolormapRaw(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccolormapRaw(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccolorwedgeRaw(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccolorwedgeRaw(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdatarangeRaw(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdatarangeRaw(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccontourlevelsRaw(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccontourlevelsRaw(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccontourthicknessRaw(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccontourthicknessRaw(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccontourcolorRaw(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccontourcolorRaw(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncchannelRaw(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncchannelRaw(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynczoomlevelRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynczoomlevelRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynczoomboxRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynczoomboxRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncoutputRaw(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncoutputRaw(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>* AsyncfileinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::FileInfo>* PrepareAsyncfileinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>* AsynckeyinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::KeyInfo>* PrepareAsynckeyinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>* AsynccwdRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::Path>* PrepareAsynccwdRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdoneRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdoneRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>* AsyncinteractivemaskRaw(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rpc::img::InteractiveMaskResult>* PrepareAsyncinteractivemaskRaw(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status panel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::rpc::img::Id* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> Asyncpanel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(AsyncpanelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> PrepareAsyncpanel(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(PrepareAsyncpanelRaw(context, request, cq));
    }
    ::grpc::Status hide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynchide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynchideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynchide(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynchideRaw(context, request, cq));
    }
    ::grpc::Status show(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncshow(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncshowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncshow(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncshowRaw(context, request, cq));
    }
    ::grpc::Status freeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncfreezeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncfreezeRaw(context, request, cq));
    }
    ::grpc::Status unfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncunfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncunfreezeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncunfreeze(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncunfreezeRaw(context, request, cq));
    }
    ::grpc::Status close(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncclose(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncclose(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccloseRaw(context, request, cq));
    }
    ::grpc::Status release(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncrelease(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncreleaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncrelease(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncreleaseRaw(context, request, cq));
    }
    ::grpc::Status axes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncaxes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncaxesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncaxes(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncaxesRaw(context, request, cq));
    }
    ::grpc::Status popup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncpopup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncpopupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncpopup(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncpopupRaw(context, request, cq));
    }
    ::grpc::Status load(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::rpc::img::Id* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> Asyncload(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(AsyncloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> PrepareAsyncload(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(PrepareAsyncloadRaw(context, request, cq));
    }
    ::grpc::Status reload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncreload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncreloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncreload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncreloadRaw(context, request, cq));
    }
    ::grpc::Status unload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncunload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncunloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncunload(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncunloadRaw(context, request, cq));
    }
    ::grpc::Status restore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::rpc::img::Id* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> Asyncrestore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(AsyncrestoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>> PrepareAsyncrestore(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>>(PrepareAsyncrestoreRaw(context, request, cq));
    }
    ::grpc::Status colormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccolormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccolormapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccolormap(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccolormapRaw(context, request, cq));
    }
    ::grpc::Status colorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccolorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccolorwedgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccolorwedge(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccolorwedgeRaw(context, request, cq));
    }
    ::grpc::Status datarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncdatarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdatarangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdatarange(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdatarangeRaw(context, request, cq));
    }
    ::grpc::Status contourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccontourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccontourlevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccontourlevels(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccontourlevelsRaw(context, request, cq));
    }
    ::grpc::Status contourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccontourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccontourthicknessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccontourthickness(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccontourthicknessRaw(context, request, cq));
    }
    ::grpc::Status contourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccontourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccontourcolorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccontourcolor(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccontourcolorRaw(context, request, cq));
    }
    ::grpc::Status channel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncchannel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncchannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncchannel(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncchannelRaw(context, request, cq));
    }
    ::grpc::Status zoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynczoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynczoomlevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynczoomlevel(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynczoomlevelRaw(context, request, cq));
    }
    ::grpc::Status zoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynczoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynczoomboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynczoombox(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynczoomboxRaw(context, request, cq));
    }
    ::grpc::Status output(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncoutput(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncoutputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncoutput(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncoutputRaw(context, request, cq));
    }
    ::grpc::Status fileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::rpc::img::FileInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>> Asyncfileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>>(AsyncfileinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>> PrepareAsyncfileinfo(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>>(PrepareAsyncfileinfoRaw(context, request, cq));
    }
    ::grpc::Status keyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::rpc::img::KeyInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>> Asynckeyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>>(AsynckeyinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>> PrepareAsynckeyinfo(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>>(PrepareAsynckeyinfoRaw(context, request, cq));
    }
    ::grpc::Status cwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::rpc::img::Path* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>> Asynccwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>>(AsynccwdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>> PrepareAsynccwd(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>>(PrepareAsynccwdRaw(context, request, cq));
    }
    ::grpc::Status done(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncdone(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdoneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdone(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdoneRaw(context, request, cq));
    }
    ::grpc::Status interactivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::rpc::img::InteractiveMaskResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>> Asyncinteractivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>>(AsyncinteractivemaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>> PrepareAsyncinteractivemask(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>>(PrepareAsyncinteractivemaskRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* AsyncpanelRaw(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* PrepareAsyncpanelRaw(::grpc::ClientContext* context, const ::rpc::img::NewPanel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynchideRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynchideRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncshowRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncshowRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncunfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncunfreezeRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccloseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccloseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncreleaseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncreleaseRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncaxesRaw(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncaxesRaw(::grpc::ClientContext* context, const ::rpc::img::Axes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncpopupRaw(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncpopupRaw(::grpc::ClientContext* context, const ::rpc::img::PopUp& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* AsyncloadRaw(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* PrepareAsyncloadRaw(::grpc::ClientContext* context, const ::rpc::img::NewData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncreloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncreloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncunloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncunloadRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* AsyncrestoreRaw(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Id>* PrepareAsyncrestoreRaw(::grpc::ClientContext* context, const ::rpc::img::Restore& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccolormapRaw(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccolormapRaw(::grpc::ClientContext* context, const ::rpc::img::ColorMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccolorwedgeRaw(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccolorwedgeRaw(::grpc::ClientContext* context, const ::rpc::img::Toggle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdatarangeRaw(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdatarangeRaw(::grpc::ClientContext* context, const ::rpc::img::DataRange& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccontourlevelsRaw(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccontourlevelsRaw(::grpc::ClientContext* context, const ::rpc::img::ContourLevels& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccontourthicknessRaw(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccontourthicknessRaw(::grpc::ClientContext* context, const ::rpc::img::ContourThickness& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccontourcolorRaw(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccontourcolorRaw(::grpc::ClientContext* context, const ::rpc::img::ContourColor& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncchannelRaw(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncchannelRaw(::grpc::ClientContext* context, const ::rpc::img::SetChannel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynczoomlevelRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynczoomlevelRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomLevel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynczoomboxRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynczoomboxRaw(::grpc::ClientContext* context, const ::rpc::img::SetZoomBox& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncoutputRaw(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncoutputRaw(::grpc::ClientContext* context, const ::rpc::img::Output& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>* AsyncfileinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::FileInfo>* PrepareAsyncfileinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>* AsynckeyinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::KeyInfo>* PrepareAsynckeyinfoRaw(::grpc::ClientContext* context, const ::rpc::img::Id& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>* AsynccwdRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::Path>* PrepareAsynccwdRaw(::grpc::ClientContext* context, const ::rpc::img::Path& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdoneRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdoneRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>* AsyncinteractivemaskRaw(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rpc::img::InteractiveMaskResult>* PrepareAsyncinteractivemaskRaw(::grpc::ClientContext* context, const ::rpc::img::InteractiveMaskOptions& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_panel_;
    const ::grpc::internal::RpcMethod rpcmethod_hide_;
    const ::grpc::internal::RpcMethod rpcmethod_show_;
    const ::grpc::internal::RpcMethod rpcmethod_freeze_;
    const ::grpc::internal::RpcMethod rpcmethod_unfreeze_;
    const ::grpc::internal::RpcMethod rpcmethod_close_;
    const ::grpc::internal::RpcMethod rpcmethod_release_;
    const ::grpc::internal::RpcMethod rpcmethod_axes_;
    const ::grpc::internal::RpcMethod rpcmethod_popup_;
    const ::grpc::internal::RpcMethod rpcmethod_load_;
    const ::grpc::internal::RpcMethod rpcmethod_reload_;
    const ::grpc::internal::RpcMethod rpcmethod_unload_;
    const ::grpc::internal::RpcMethod rpcmethod_restore_;
    const ::grpc::internal::RpcMethod rpcmethod_colormap_;
    const ::grpc::internal::RpcMethod rpcmethod_colorwedge_;
    const ::grpc::internal::RpcMethod rpcmethod_datarange_;
    const ::grpc::internal::RpcMethod rpcmethod_contourlevels_;
    const ::grpc::internal::RpcMethod rpcmethod_contourthickness_;
    const ::grpc::internal::RpcMethod rpcmethod_contourcolor_;
    const ::grpc::internal::RpcMethod rpcmethod_channel_;
    const ::grpc::internal::RpcMethod rpcmethod_zoomlevel_;
    const ::grpc::internal::RpcMethod rpcmethod_zoombox_;
    const ::grpc::internal::RpcMethod rpcmethod_output_;
    const ::grpc::internal::RpcMethod rpcmethod_fileinfo_;
    const ::grpc::internal::RpcMethod rpcmethod_keyinfo_;
    const ::grpc::internal::RpcMethod rpcmethod_cwd_;
    const ::grpc::internal::RpcMethod rpcmethod_done_;
    const ::grpc::internal::RpcMethod rpcmethod_interactivemask_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // create a new panel (which may or may not be immediately 
    virtual ::grpc::Status panel(::grpc::ServerContext* context, const ::rpc::img::NewPanel* request, ::rpc::img::Id* response);
    virtual ::grpc::Status hide(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status show(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status freeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status unfreeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status close(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status release(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status axes(::grpc::ServerContext* context, const ::rpc::img::Axes* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status popup(::grpc::ServerContext* context, const ::rpc::img::PopUp* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status load(::grpc::ServerContext* context, const ::rpc::img::NewData* request, ::rpc::img::Id* response);
    virtual ::grpc::Status reload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status unload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status restore(::grpc::ServerContext* context, const ::rpc::img::Restore* request, ::rpc::img::Id* response);
    virtual ::grpc::Status colormap(::grpc::ServerContext* context, const ::rpc::img::ColorMap* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status colorwedge(::grpc::ServerContext* context, const ::rpc::img::Toggle* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status datarange(::grpc::ServerContext* context, const ::rpc::img::DataRange* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status contourlevels(::grpc::ServerContext* context, const ::rpc::img::ContourLevels* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status contourthickness(::grpc::ServerContext* context, const ::rpc::img::ContourThickness* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status contourcolor(::grpc::ServerContext* context, const ::rpc::img::ContourColor* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status channel(::grpc::ServerContext* context, const ::rpc::img::SetChannel* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status zoomlevel(::grpc::ServerContext* context, const ::rpc::img::SetZoomLevel* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status zoombox(::grpc::ServerContext* context, const ::rpc::img::SetZoomBox* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status output(::grpc::ServerContext* context, const ::rpc::img::Output* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status fileinfo(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::FileInfo* response);
    virtual ::grpc::Status keyinfo(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::rpc::img::KeyInfo* response);
    virtual ::grpc::Status cwd(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::Path* response);
    virtual ::grpc::Status done(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status interactivemask(::grpc::ServerContext* context, const ::rpc::img::InteractiveMaskOptions* request, ::rpc::img::InteractiveMaskResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_panel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_panel() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_panel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status panel(::grpc::ServerContext* context, const ::rpc::img::NewPanel* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpanel(::grpc::ServerContext* context, ::rpc::img::NewPanel* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::Id>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_hide() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_hide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hide(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthide(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_show : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_show() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_show() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestshow(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_freeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_freeze() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_freeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfreeze(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unfreeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_unfreeze() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_unfreeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unfreeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunfreeze(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_close() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclose(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_release() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status release(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrelease(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_axes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_axes() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_axes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status axes(::grpc::ServerContext* context, const ::rpc::img::Axes* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestaxes(::grpc::ServerContext* context, ::rpc::img::Axes* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_popup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_popup() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_popup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status popup(::grpc::ServerContext* context, const ::rpc::img::PopUp* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpopup(::grpc::ServerContext* context, ::rpc::img::PopUp* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_load() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* context, const ::rpc::img::NewData* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload(::grpc::ServerContext* context, ::rpc::img::NewData* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::Id>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_reload() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_reload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreload(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_unload() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_unload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunload(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_restore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_restore() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_restore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restore(::grpc::ServerContext* context, const ::rpc::img::Restore* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrestore(::grpc::ServerContext* context, ::rpc::img::Restore* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::Id>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_colormap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_colormap() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_colormap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status colormap(::grpc::ServerContext* context, const ::rpc::img::ColorMap* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcolormap(::grpc::ServerContext* context, ::rpc::img::ColorMap* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_colorwedge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_colorwedge() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_colorwedge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status colorwedge(::grpc::ServerContext* context, const ::rpc::img::Toggle* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcolorwedge(::grpc::ServerContext* context, ::rpc::img::Toggle* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_datarange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_datarange() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_datarange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status datarange(::grpc::ServerContext* context, const ::rpc::img::DataRange* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdatarange(::grpc::ServerContext* context, ::rpc::img::DataRange* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_contourlevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_contourlevels() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_contourlevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourlevels(::grpc::ServerContext* context, const ::rpc::img::ContourLevels* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcontourlevels(::grpc::ServerContext* context, ::rpc::img::ContourLevels* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_contourthickness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_contourthickness() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_contourthickness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourthickness(::grpc::ServerContext* context, const ::rpc::img::ContourThickness* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcontourthickness(::grpc::ServerContext* context, ::rpc::img::ContourThickness* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_contourcolor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_contourcolor() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_contourcolor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourcolor(::grpc::ServerContext* context, const ::rpc::img::ContourColor* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcontourcolor(::grpc::ServerContext* context, ::rpc::img::ContourColor* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_channel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_channel() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_channel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel(::grpc::ServerContext* context, const ::rpc::img::SetChannel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestchannel(::grpc::ServerContext* context, ::rpc::img::SetChannel* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_zoomlevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_zoomlevel() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_zoomlevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status zoomlevel(::grpc::ServerContext* context, const ::rpc::img::SetZoomLevel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestzoomlevel(::grpc::ServerContext* context, ::rpc::img::SetZoomLevel* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_zoombox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_zoombox() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_zoombox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status zoombox(::grpc::ServerContext* context, const ::rpc::img::SetZoomBox* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestzoombox(::grpc::ServerContext* context, ::rpc::img::SetZoomBox* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_output : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_output() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_output() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status output(::grpc::ServerContext* context, const ::rpc::img::Output* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestoutput(::grpc::ServerContext* context, ::rpc::img::Output* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_fileinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_fileinfo() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_fileinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fileinfo(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::FileInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfileinfo(::grpc::ServerContext* context, ::rpc::img::Path* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::FileInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keyinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_keyinfo() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_keyinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyinfo(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::rpc::img::KeyInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeyinfo(::grpc::ServerContext* context, ::rpc::img::Id* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::KeyInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_cwd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_cwd() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_cwd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cwd(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::Path* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcwd(::grpc::ServerContext* context, ::rpc::img::Path* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::Path>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_done() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status done(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdone(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_interactivemask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_interactivemask() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_interactivemask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status interactivemask(::grpc::ServerContext* context, const ::rpc::img::InteractiveMaskOptions* request, ::rpc::img::InteractiveMaskResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinteractivemask(::grpc::ServerContext* context, ::rpc::img::InteractiveMaskOptions* request, ::grpc::ServerAsyncResponseWriter< ::rpc::img::InteractiveMaskResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_panel<WithAsyncMethod_hide<WithAsyncMethod_show<WithAsyncMethod_freeze<WithAsyncMethod_unfreeze<WithAsyncMethod_close<WithAsyncMethod_release<WithAsyncMethod_axes<WithAsyncMethod_popup<WithAsyncMethod_load<WithAsyncMethod_reload<WithAsyncMethod_unload<WithAsyncMethod_restore<WithAsyncMethod_colormap<WithAsyncMethod_colorwedge<WithAsyncMethod_datarange<WithAsyncMethod_contourlevels<WithAsyncMethod_contourthickness<WithAsyncMethod_contourcolor<WithAsyncMethod_channel<WithAsyncMethod_zoomlevel<WithAsyncMethod_zoombox<WithAsyncMethod_output<WithAsyncMethod_fileinfo<WithAsyncMethod_keyinfo<WithAsyncMethod_cwd<WithAsyncMethod_done<WithAsyncMethod_interactivemask<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_panel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_panel() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_panel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status panel(::grpc::ServerContext* context, const ::rpc::img::NewPanel* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_hide() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_hide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hide(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_show : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_show() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_show() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_freeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_freeze() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_freeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unfreeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_unfreeze() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_unfreeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unfreeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_close() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status close(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_release() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status release(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_axes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_axes() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_axes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status axes(::grpc::ServerContext* context, const ::rpc::img::Axes* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_popup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_popup() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_popup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status popup(::grpc::ServerContext* context, const ::rpc::img::PopUp* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_load() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* context, const ::rpc::img::NewData* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_reload() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_reload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_unload() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_unload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_restore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_restore() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_restore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restore(::grpc::ServerContext* context, const ::rpc::img::Restore* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_colormap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_colormap() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_colormap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status colormap(::grpc::ServerContext* context, const ::rpc::img::ColorMap* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_colorwedge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_colorwedge() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_colorwedge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status colorwedge(::grpc::ServerContext* context, const ::rpc::img::Toggle* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_datarange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_datarange() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_datarange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status datarange(::grpc::ServerContext* context, const ::rpc::img::DataRange* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_contourlevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_contourlevels() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_contourlevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourlevels(::grpc::ServerContext* context, const ::rpc::img::ContourLevels* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_contourthickness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_contourthickness() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_contourthickness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourthickness(::grpc::ServerContext* context, const ::rpc::img::ContourThickness* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_contourcolor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_contourcolor() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_contourcolor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contourcolor(::grpc::ServerContext* context, const ::rpc::img::ContourColor* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_channel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_channel() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_channel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel(::grpc::ServerContext* context, const ::rpc::img::SetChannel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_zoomlevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_zoomlevel() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_zoomlevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status zoomlevel(::grpc::ServerContext* context, const ::rpc::img::SetZoomLevel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_zoombox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_zoombox() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_zoombox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status zoombox(::grpc::ServerContext* context, const ::rpc::img::SetZoomBox* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_output : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_output() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_output() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status output(::grpc::ServerContext* context, const ::rpc::img::Output* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_fileinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_fileinfo() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_fileinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fileinfo(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::FileInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keyinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_keyinfo() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_keyinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyinfo(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::rpc::img::KeyInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_cwd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_cwd() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_cwd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cwd(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::Path* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_done() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status done(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_interactivemask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_interactivemask() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_interactivemask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status interactivemask(::grpc::ServerContext* context, const ::rpc::img::InteractiveMaskOptions* request, ::rpc::img::InteractiveMaskResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_panel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_panel() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::NewPanel, ::rpc::img::Id>(std::bind(&WithStreamedUnaryMethod_panel<BaseClass>::Streamedpanel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_panel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status panel(::grpc::ServerContext* context, const ::rpc::img::NewPanel* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpanel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::NewPanel,::rpc::img::Id>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_hide() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_hide<BaseClass>::Streamedhide, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_hide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hide(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhide(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_show : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_show() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_show<BaseClass>::Streamedshow, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_show() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status show(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedshow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_freeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_freeze() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_freeze<BaseClass>::Streamedfreeze, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_freeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status freeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedfreeze(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unfreeze : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_unfreeze() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_unfreeze<BaseClass>::Streamedunfreeze, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_unfreeze() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unfreeze(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedunfreeze(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_close() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_close<BaseClass>::Streamedclose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status close(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_release() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_release<BaseClass>::Streamedrelease, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status release(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrelease(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_axes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_axes() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Axes, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_axes<BaseClass>::Streamedaxes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_axes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status axes(::grpc::ServerContext* context, const ::rpc::img::Axes* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedaxes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Axes,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_popup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_popup() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::PopUp, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_popup<BaseClass>::Streamedpopup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_popup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status popup(::grpc::ServerContext* context, const ::rpc::img::PopUp* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpopup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::PopUp,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_load() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::NewData, ::rpc::img::Id>(std::bind(&WithStreamedUnaryMethod_load<BaseClass>::Streamedload, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status load(::grpc::ServerContext* context, const ::rpc::img::NewData* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::NewData,::rpc::img::Id>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_reload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_reload() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_reload<BaseClass>::Streamedreload, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_reload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status reload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_unload() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_unload<BaseClass>::Streamedunload, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_unload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unload(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedunload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_restore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_restore() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Restore, ::rpc::img::Id>(std::bind(&WithStreamedUnaryMethod_restore<BaseClass>::Streamedrestore, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_restore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status restore(::grpc::ServerContext* context, const ::rpc::img::Restore* request, ::rpc::img::Id* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrestore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Restore,::rpc::img::Id>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_colormap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_colormap() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::ColorMap, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_colormap<BaseClass>::Streamedcolormap, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_colormap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status colormap(::grpc::ServerContext* context, const ::rpc::img::ColorMap* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcolormap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::ColorMap,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_colorwedge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_colorwedge() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Toggle, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_colorwedge<BaseClass>::Streamedcolorwedge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_colorwedge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status colorwedge(::grpc::ServerContext* context, const ::rpc::img::Toggle* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcolorwedge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Toggle,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_datarange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_datarange() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::DataRange, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_datarange<BaseClass>::Streameddatarange, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_datarange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status datarange(::grpc::ServerContext* context, const ::rpc::img::DataRange* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddatarange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::DataRange,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_contourlevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_contourlevels() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::ContourLevels, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_contourlevels<BaseClass>::Streamedcontourlevels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_contourlevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status contourlevels(::grpc::ServerContext* context, const ::rpc::img::ContourLevels* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcontourlevels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::ContourLevels,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_contourthickness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_contourthickness() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::ContourThickness, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_contourthickness<BaseClass>::Streamedcontourthickness, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_contourthickness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status contourthickness(::grpc::ServerContext* context, const ::rpc::img::ContourThickness* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcontourthickness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::ContourThickness,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_contourcolor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_contourcolor() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::ContourColor, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_contourcolor<BaseClass>::Streamedcontourcolor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_contourcolor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status contourcolor(::grpc::ServerContext* context, const ::rpc::img::ContourColor* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcontourcolor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::ContourColor,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_channel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_channel() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::SetChannel, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_channel<BaseClass>::Streamedchannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_channel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status channel(::grpc::ServerContext* context, const ::rpc::img::SetChannel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedchannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::SetChannel,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_zoomlevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_zoomlevel() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::SetZoomLevel, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_zoomlevel<BaseClass>::Streamedzoomlevel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_zoomlevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status zoomlevel(::grpc::ServerContext* context, const ::rpc::img::SetZoomLevel* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedzoomlevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::SetZoomLevel,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_zoombox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_zoombox() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::SetZoomBox, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_zoombox<BaseClass>::Streamedzoombox, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_zoombox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status zoombox(::grpc::ServerContext* context, const ::rpc::img::SetZoomBox* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedzoombox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::SetZoomBox,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_output : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_output() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Output, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_output<BaseClass>::Streamedoutput, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_output() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status output(::grpc::ServerContext* context, const ::rpc::img::Output* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedoutput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Output,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_fileinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_fileinfo() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Path, ::rpc::img::FileInfo>(std::bind(&WithStreamedUnaryMethod_fileinfo<BaseClass>::Streamedfileinfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_fileinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status fileinfo(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::FileInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedfileinfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Path,::rpc::img::FileInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keyinfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_keyinfo() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Id, ::rpc::img::KeyInfo>(std::bind(&WithStreamedUnaryMethod_keyinfo<BaseClass>::Streamedkeyinfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keyinfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keyinfo(::grpc::ServerContext* context, const ::rpc::img::Id* request, ::rpc::img::KeyInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeyinfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Id,::rpc::img::KeyInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_cwd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_cwd() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::Path, ::rpc::img::Path>(std::bind(&WithStreamedUnaryMethod_cwd<BaseClass>::Streamedcwd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_cwd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status cwd(::grpc::ServerContext* context, const ::rpc::img::Path* request, ::rpc::img::Path* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcwd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::Path,::rpc::img::Path>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_done() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_done<BaseClass>::Streameddone, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status done(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddone(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_interactivemask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_interactivemask() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::rpc::img::InteractiveMaskOptions, ::rpc::img::InteractiveMaskResult>(std::bind(&WithStreamedUnaryMethod_interactivemask<BaseClass>::Streamedinteractivemask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_interactivemask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status interactivemask(::grpc::ServerContext* context, const ::rpc::img::InteractiveMaskOptions* request, ::rpc::img::InteractiveMaskResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinteractivemask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rpc::img::InteractiveMaskOptions,::rpc::img::InteractiveMaskResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_panel<WithStreamedUnaryMethod_hide<WithStreamedUnaryMethod_show<WithStreamedUnaryMethod_freeze<WithStreamedUnaryMethod_unfreeze<WithStreamedUnaryMethod_close<WithStreamedUnaryMethod_release<WithStreamedUnaryMethod_axes<WithStreamedUnaryMethod_popup<WithStreamedUnaryMethod_load<WithStreamedUnaryMethod_reload<WithStreamedUnaryMethod_unload<WithStreamedUnaryMethod_restore<WithStreamedUnaryMethod_colormap<WithStreamedUnaryMethod_colorwedge<WithStreamedUnaryMethod_datarange<WithStreamedUnaryMethod_contourlevels<WithStreamedUnaryMethod_contourthickness<WithStreamedUnaryMethod_contourcolor<WithStreamedUnaryMethod_channel<WithStreamedUnaryMethod_zoomlevel<WithStreamedUnaryMethod_zoombox<WithStreamedUnaryMethod_output<WithStreamedUnaryMethod_fileinfo<WithStreamedUnaryMethod_keyinfo<WithStreamedUnaryMethod_cwd<WithStreamedUnaryMethod_done<WithStreamedUnaryMethod_interactivemask<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_panel<WithStreamedUnaryMethod_hide<WithStreamedUnaryMethod_show<WithStreamedUnaryMethod_freeze<WithStreamedUnaryMethod_unfreeze<WithStreamedUnaryMethod_close<WithStreamedUnaryMethod_release<WithStreamedUnaryMethod_axes<WithStreamedUnaryMethod_popup<WithStreamedUnaryMethod_load<WithStreamedUnaryMethod_reload<WithStreamedUnaryMethod_unload<WithStreamedUnaryMethod_restore<WithStreamedUnaryMethod_colormap<WithStreamedUnaryMethod_colorwedge<WithStreamedUnaryMethod_datarange<WithStreamedUnaryMethod_contourlevels<WithStreamedUnaryMethod_contourthickness<WithStreamedUnaryMethod_contourcolor<WithStreamedUnaryMethod_channel<WithStreamedUnaryMethod_zoomlevel<WithStreamedUnaryMethod_zoombox<WithStreamedUnaryMethod_output<WithStreamedUnaryMethod_fileinfo<WithStreamedUnaryMethod_keyinfo<WithStreamedUnaryMethod_cwd<WithStreamedUnaryMethod_done<WithStreamedUnaryMethod_interactivemask<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace img
}  // namespace rpc


#endif  // GRPC_img_2eproto__INCLUDED
