// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plotserver_events.proto

#ifndef PROTOBUF_plotserver_5fevents_2eproto__INCLUDED
#define PROTOBUF_plotserver_5fevents_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "plotserver.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_plotserver_5fevents_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsButtonEventImpl();
void InitDefaultsButtonEvent();
void InitDefaultsCheckEventImpl();
void InitDefaultsCheckEvent();
void InitDefaultsRadioEventImpl();
void InitDefaultsRadioEvent();
void InitDefaultsLineTextEventImpl();
void InitDefaultsLineTextEvent();
void InitDefaultsSlideValueEventImpl();
void InitDefaultsSlideValueEvent();
void InitDefaultsClosingEventImpl();
void InitDefaultsClosingEvent();
inline void InitDefaults() {
  InitDefaultsButtonEvent();
  InitDefaultsCheckEvent();
  InitDefaultsRadioEvent();
  InitDefaultsLineTextEvent();
  InitDefaultsSlideValueEvent();
  InitDefaultsClosingEvent();
}
}  // namespace protobuf_plotserver_5fevents_2eproto
namespace rpc {
namespace gui {
class ButtonEvent;
class ButtonEventDefaultTypeInternal;
extern ButtonEventDefaultTypeInternal _ButtonEvent_default_instance_;
class CheckEvent;
class CheckEventDefaultTypeInternal;
extern CheckEventDefaultTypeInternal _CheckEvent_default_instance_;
class ClosingEvent;
class ClosingEventDefaultTypeInternal;
extern ClosingEventDefaultTypeInternal _ClosingEvent_default_instance_;
class LineTextEvent;
class LineTextEventDefaultTypeInternal;
extern LineTextEventDefaultTypeInternal _LineTextEvent_default_instance_;
class RadioEvent;
class RadioEventDefaultTypeInternal;
extern RadioEventDefaultTypeInternal _RadioEvent_default_instance_;
class SlideValueEvent;
class SlideValueEventDefaultTypeInternal;
extern SlideValueEventDefaultTypeInternal _SlideValueEvent_default_instance_;
}  // namespace gui
}  // namespace rpc
namespace rpc {
namespace gui {

// ===================================================================

class ButtonEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.ButtonEvent) */ {
 public:
  ButtonEvent();
  virtual ~ButtonEvent();

  ButtonEvent(const ButtonEvent& from);

  inline ButtonEvent& operator=(const ButtonEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ButtonEvent(ButtonEvent&& from) noexcept
    : ButtonEvent() {
    *this = ::std::move(from);
  }

  inline ButtonEvent& operator=(ButtonEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ButtonEvent* internal_default_instance() {
    return reinterpret_cast<const ButtonEvent*>(
               &_ButtonEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ButtonEvent* other);
  friend void swap(ButtonEvent& a, ButtonEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ButtonEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  ButtonEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ButtonEvent& from);
  void MergeFrom(const ButtonEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ButtonEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.gui.ButtonEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rpc::gui::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsButtonEventImpl();
};
// -------------------------------------------------------------------

class CheckEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.CheckEvent) */ {
 public:
  CheckEvent();
  virtual ~CheckEvent();

  CheckEvent(const CheckEvent& from);

  inline CheckEvent& operator=(const CheckEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckEvent(CheckEvent&& from) noexcept
    : CheckEvent() {
    *this = ::std::move(from);
  }

  inline CheckEvent& operator=(CheckEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckEvent* internal_default_instance() {
    return reinterpret_cast<const CheckEvent*>(
               &_CheckEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CheckEvent* other);
  friend void swap(CheckEvent& a, CheckEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckEvent& from);
  void MergeFrom(const CheckEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // int32 state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.CheckEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rpc::gui::Id* panel_;
  ::google::protobuf::int32 state_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsCheckEventImpl();
};
// -------------------------------------------------------------------

class RadioEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.RadioEvent) */ {
 public:
  RadioEvent();
  virtual ~RadioEvent();

  RadioEvent(const RadioEvent& from);

  inline RadioEvent& operator=(const RadioEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadioEvent(RadioEvent&& from) noexcept
    : RadioEvent() {
    *this = ::std::move(from);
  }

  inline RadioEvent& operator=(RadioEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadioEvent* internal_default_instance() {
    return reinterpret_cast<const RadioEvent*>(
               &_RadioEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RadioEvent* other);
  friend void swap(RadioEvent& a, RadioEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadioEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  RadioEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RadioEvent& from);
  void MergeFrom(const RadioEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RadioEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // bool state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:rpc.gui.RadioEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rpc::gui::Id* panel_;
  bool state_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsRadioEventImpl();
};
// -------------------------------------------------------------------

class LineTextEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.LineTextEvent) */ {
 public:
  LineTextEvent();
  virtual ~LineTextEvent();

  LineTextEvent(const LineTextEvent& from);

  inline LineTextEvent& operator=(const LineTextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineTextEvent(LineTextEvent&& from) noexcept
    : LineTextEvent() {
    *this = ::std::move(from);
  }

  inline LineTextEvent& operator=(LineTextEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LineTextEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineTextEvent* internal_default_instance() {
    return reinterpret_cast<const LineTextEvent*>(
               &_LineTextEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LineTextEvent* other);
  friend void swap(LineTextEvent& a, LineTextEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineTextEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  LineTextEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LineTextEvent& from);
  void MergeFrom(const LineTextEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LineTextEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string text = 3;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.gui.LineTextEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::rpc::gui::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsLineTextEventImpl();
};
// -------------------------------------------------------------------

class SlideValueEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.SlideValueEvent) */ {
 public:
  SlideValueEvent();
  virtual ~SlideValueEvent();

  SlideValueEvent(const SlideValueEvent& from);

  inline SlideValueEvent& operator=(const SlideValueEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SlideValueEvent(SlideValueEvent&& from) noexcept
    : SlideValueEvent() {
    *this = ::std::move(from);
  }

  inline SlideValueEvent& operator=(SlideValueEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlideValueEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlideValueEvent* internal_default_instance() {
    return reinterpret_cast<const SlideValueEvent*>(
               &_SlideValueEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SlideValueEvent* other);
  friend void swap(SlideValueEvent& a, SlideValueEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SlideValueEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  SlideValueEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlideValueEvent& from);
  void MergeFrom(const SlideValueEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlideValueEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // int32 value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.SlideValueEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rpc::gui::Id* panel_;
  ::google::protobuf::int32 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsSlideValueEventImpl();
};
// -------------------------------------------------------------------

class ClosingEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.ClosingEvent) */ {
 public:
  ClosingEvent();
  virtual ~ClosingEvent();

  ClosingEvent(const ClosingEvent& from);

  inline ClosingEvent& operator=(const ClosingEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClosingEvent(ClosingEvent&& from) noexcept
    : ClosingEvent() {
    *this = ::std::move(from);
  }

  inline ClosingEvent& operator=(ClosingEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClosingEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClosingEvent* internal_default_instance() {
    return reinterpret_cast<const ClosingEvent*>(
               &_ClosingEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ClosingEvent* other);
  friend void swap(ClosingEvent& a, ClosingEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClosingEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  ClosingEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClosingEvent& from);
  void MergeFrom(const ClosingEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClosingEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.gui.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // bool gone = 2;
  void clear_gone();
  static const int kGoneFieldNumber = 2;
  bool gone() const;
  void set_gone(bool value);

  // @@protoc_insertion_point(class_scope:rpc.gui.ClosingEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::gui::Id* panel_;
  bool gone_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_5fevents_2eproto::TableStruct;
  friend void ::protobuf_plotserver_5fevents_2eproto::InitDefaultsClosingEventImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ButtonEvent

// .rpc.gui.Id panel = 1;
inline bool ButtonEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& ButtonEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.ButtonEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* ButtonEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.ButtonEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* ButtonEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.ButtonEvent.panel)
  return panel_;
}
inline void ButtonEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.ButtonEvent.panel)
}

// string name = 2;
inline void ButtonEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ButtonEvent::name() const {
  // @@protoc_insertion_point(field_get:rpc.gui.ButtonEvent.name)
  return name_.GetNoArena();
}
inline void ButtonEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.ButtonEvent.name)
}
#if LANG_CXX11
inline void ButtonEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.ButtonEvent.name)
}
#endif
inline void ButtonEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.ButtonEvent.name)
}
inline void ButtonEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.ButtonEvent.name)
}
inline ::std::string* ButtonEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.ButtonEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ButtonEvent::release_name() {
  // @@protoc_insertion_point(field_release:rpc.gui.ButtonEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ButtonEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.ButtonEvent.name)
}

// -------------------------------------------------------------------

// CheckEvent

// .rpc.gui.Id panel = 1;
inline bool CheckEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& CheckEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.CheckEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* CheckEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.CheckEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* CheckEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.CheckEvent.panel)
  return panel_;
}
inline void CheckEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.CheckEvent.panel)
}

// string name = 2;
inline void CheckEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckEvent::name() const {
  // @@protoc_insertion_point(field_get:rpc.gui.CheckEvent.name)
  return name_.GetNoArena();
}
inline void CheckEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.CheckEvent.name)
}
#if LANG_CXX11
inline void CheckEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.CheckEvent.name)
}
#endif
inline void CheckEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.CheckEvent.name)
}
inline void CheckEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.CheckEvent.name)
}
inline ::std::string* CheckEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.CheckEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckEvent::release_name() {
  // @@protoc_insertion_point(field_release:rpc.gui.CheckEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.CheckEvent.name)
}

// int32 state = 3;
inline void CheckEvent::clear_state() {
  state_ = 0;
}
inline ::google::protobuf::int32 CheckEvent::state() const {
  // @@protoc_insertion_point(field_get:rpc.gui.CheckEvent.state)
  return state_;
}
inline void CheckEvent::set_state(::google::protobuf::int32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.CheckEvent.state)
}

// -------------------------------------------------------------------

// RadioEvent

// .rpc.gui.Id panel = 1;
inline bool RadioEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& RadioEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.RadioEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* RadioEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.RadioEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* RadioEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.RadioEvent.panel)
  return panel_;
}
inline void RadioEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.RadioEvent.panel)
}

// string name = 2;
inline void RadioEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RadioEvent::name() const {
  // @@protoc_insertion_point(field_get:rpc.gui.RadioEvent.name)
  return name_.GetNoArena();
}
inline void RadioEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.RadioEvent.name)
}
#if LANG_CXX11
inline void RadioEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.RadioEvent.name)
}
#endif
inline void RadioEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.RadioEvent.name)
}
inline void RadioEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.RadioEvent.name)
}
inline ::std::string* RadioEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.RadioEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RadioEvent::release_name() {
  // @@protoc_insertion_point(field_release:rpc.gui.RadioEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RadioEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.RadioEvent.name)
}

// bool state = 3;
inline void RadioEvent::clear_state() {
  state_ = false;
}
inline bool RadioEvent::state() const {
  // @@protoc_insertion_point(field_get:rpc.gui.RadioEvent.state)
  return state_;
}
inline void RadioEvent::set_state(bool value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.RadioEvent.state)
}

// -------------------------------------------------------------------

// LineTextEvent

// .rpc.gui.Id panel = 1;
inline bool LineTextEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& LineTextEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.LineTextEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* LineTextEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.LineTextEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* LineTextEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.LineTextEvent.panel)
  return panel_;
}
inline void LineTextEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.LineTextEvent.panel)
}

// string name = 2;
inline void LineTextEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LineTextEvent::name() const {
  // @@protoc_insertion_point(field_get:rpc.gui.LineTextEvent.name)
  return name_.GetNoArena();
}
inline void LineTextEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.LineTextEvent.name)
}
#if LANG_CXX11
inline void LineTextEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.LineTextEvent.name)
}
#endif
inline void LineTextEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.LineTextEvent.name)
}
inline void LineTextEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.LineTextEvent.name)
}
inline ::std::string* LineTextEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.LineTextEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineTextEvent::release_name() {
  // @@protoc_insertion_point(field_release:rpc.gui.LineTextEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineTextEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.LineTextEvent.name)
}

// string text = 3;
inline void LineTextEvent::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LineTextEvent::text() const {
  // @@protoc_insertion_point(field_get:rpc.gui.LineTextEvent.text)
  return text_.GetNoArena();
}
inline void LineTextEvent::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.LineTextEvent.text)
}
#if LANG_CXX11
inline void LineTextEvent::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.LineTextEvent.text)
}
#endif
inline void LineTextEvent::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.LineTextEvent.text)
}
inline void LineTextEvent::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.LineTextEvent.text)
}
inline ::std::string* LineTextEvent::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.LineTextEvent.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineTextEvent::release_text() {
  // @@protoc_insertion_point(field_release:rpc.gui.LineTextEvent.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineTextEvent::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.LineTextEvent.text)
}

// -------------------------------------------------------------------

// SlideValueEvent

// .rpc.gui.Id panel = 1;
inline bool SlideValueEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& SlideValueEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.SlideValueEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* SlideValueEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.SlideValueEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* SlideValueEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.SlideValueEvent.panel)
  return panel_;
}
inline void SlideValueEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.SlideValueEvent.panel)
}

// string name = 2;
inline void SlideValueEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SlideValueEvent::name() const {
  // @@protoc_insertion_point(field_get:rpc.gui.SlideValueEvent.name)
  return name_.GetNoArena();
}
inline void SlideValueEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.SlideValueEvent.name)
}
#if LANG_CXX11
inline void SlideValueEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.SlideValueEvent.name)
}
#endif
inline void SlideValueEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.SlideValueEvent.name)
}
inline void SlideValueEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.SlideValueEvent.name)
}
inline ::std::string* SlideValueEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.SlideValueEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlideValueEvent::release_name() {
  // @@protoc_insertion_point(field_release:rpc.gui.SlideValueEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlideValueEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.SlideValueEvent.name)
}

// int32 value = 3;
inline void SlideValueEvent::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 SlideValueEvent::value() const {
  // @@protoc_insertion_point(field_get:rpc.gui.SlideValueEvent.value)
  return value_;
}
inline void SlideValueEvent::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.SlideValueEvent.value)
}

// -------------------------------------------------------------------

// ClosingEvent

// .rpc.gui.Id panel = 1;
inline bool ClosingEvent::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline const ::rpc::gui::Id& ClosingEvent::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.ClosingEvent.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* ClosingEvent::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.ClosingEvent.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* ClosingEvent::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.ClosingEvent.panel)
  return panel_;
}
inline void ClosingEvent::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(panel_);
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.ClosingEvent.panel)
}

// bool gone = 2;
inline void ClosingEvent::clear_gone() {
  gone_ = false;
}
inline bool ClosingEvent::gone() const {
  // @@protoc_insertion_point(field_get:rpc.gui.ClosingEvent.gone)
  return gone_;
}
inline void ClosingEvent::set_gone(bool value) {
  
  gone_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.ClosingEvent.gone)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gui
}  // namespace rpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_plotserver_5fevents_2eproto__INCLUDED
