// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plotserver.proto

#ifndef PROTOBUF_plotserver_2eproto__INCLUDED
#define PROTOBUF_plotserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_plotserver_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsIdImpl();
void InitDefaultsId();
void InitDefaultsNewPanelImpl();
void InitDefaultsNewPanel();
void InitDefaultsColorsImpl();
void InitDefaultsColors();
void InitDefaultsColorMapsImpl();
void InitDefaultsColorMaps();
void InitDefaultsSymbolsImpl();
void InitDefaultsSymbols();
void InitDefaultsNewLineImpl();
void InitDefaultsNewLine();
void InitDefaultsNewScatterImpl();
void InitDefaultsNewScatter();
void InitDefaultsNewHistogramImpl();
void InitDefaultsNewHistogram();
void InitDefaultsNewRasterImpl();
void InitDefaultsNewRaster();
void InitDefaultsLabelImpl();
void InitDefaultsLabel();
void InitDefaultsDockSpecImpl();
void InitDefaultsDockSpec();
inline void InitDefaults() {
  InitDefaultsId();
  InitDefaultsNewPanel();
  InitDefaultsColors();
  InitDefaultsColorMaps();
  InitDefaultsSymbols();
  InitDefaultsNewLine();
  InitDefaultsNewScatter();
  InitDefaultsNewHistogram();
  InitDefaultsNewRaster();
  InitDefaultsLabel();
  InitDefaultsDockSpec();
}
}  // namespace protobuf_plotserver_2eproto
namespace rpc {
namespace gui {
class ColorMaps;
class ColorMapsDefaultTypeInternal;
extern ColorMapsDefaultTypeInternal _ColorMaps_default_instance_;
class Colors;
class ColorsDefaultTypeInternal;
extern ColorsDefaultTypeInternal _Colors_default_instance_;
class DockSpec;
class DockSpecDefaultTypeInternal;
extern DockSpecDefaultTypeInternal _DockSpec_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class Label;
class LabelDefaultTypeInternal;
extern LabelDefaultTypeInternal _Label_default_instance_;
class NewHistogram;
class NewHistogramDefaultTypeInternal;
extern NewHistogramDefaultTypeInternal _NewHistogram_default_instance_;
class NewLine;
class NewLineDefaultTypeInternal;
extern NewLineDefaultTypeInternal _NewLine_default_instance_;
class NewPanel;
class NewPanelDefaultTypeInternal;
extern NewPanelDefaultTypeInternal _NewPanel_default_instance_;
class NewRaster;
class NewRasterDefaultTypeInternal;
extern NewRasterDefaultTypeInternal _NewRaster_default_instance_;
class NewScatter;
class NewScatterDefaultTypeInternal;
extern NewScatterDefaultTypeInternal _NewScatter_default_instance_;
class Symbols;
class SymbolsDefaultTypeInternal;
extern SymbolsDefaultTypeInternal _Symbols_default_instance_;
}  // namespace gui
}  // namespace rpc
namespace rpc {
namespace gui {

// ===================================================================

class Id : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.Id) */ {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(Id&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Id& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Id* other);
  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Id* New() const PROTOBUF_FINAL { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.Id)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsIdImpl();
};
// -------------------------------------------------------------------

class NewPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.NewPanel) */ {
 public:
  NewPanel();
  virtual ~NewPanel();

  NewPanel(const NewPanel& from);

  inline NewPanel& operator=(const NewPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewPanel(NewPanel&& from) noexcept
    : NewPanel() {
    *this = ::std::move(from);
  }

  inline NewPanel& operator=(NewPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewPanel* internal_default_instance() {
    return reinterpret_cast<const NewPanel*>(
               &_NewPanel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NewPanel* other);
  friend void swap(NewPanel& a, NewPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewPanel* New() const PROTOBUF_FINAL { return New(NULL); }

  NewPanel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewPanel& from);
  void MergeFrom(const NewPanel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 size = 5;
  int size_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::int32 size(int index) const;
  void set_size(int index, ::google::protobuf::int32 value);
  void add_size(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      size() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_size();

  // string title = 1;
  void clear_title();
  static const int kTitleFieldNumber = 1;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string xlabel = 2;
  void clear_xlabel();
  static const int kXlabelFieldNumber = 2;
  const ::std::string& xlabel() const;
  void set_xlabel(const ::std::string& value);
  #if LANG_CXX11
  void set_xlabel(::std::string&& value);
  #endif
  void set_xlabel(const char* value);
  void set_xlabel(const char* value, size_t size);
  ::std::string* mutable_xlabel();
  ::std::string* release_xlabel();
  void set_allocated_xlabel(::std::string* xlabel);

  // string ylabel = 3;
  void clear_ylabel();
  static const int kYlabelFieldNumber = 3;
  const ::std::string& ylabel() const;
  void set_ylabel(const ::std::string& value);
  #if LANG_CXX11
  void set_ylabel(::std::string&& value);
  #endif
  void set_ylabel(const char* value);
  void set_ylabel(const char* value, size_t size);
  ::std::string* mutable_ylabel();
  ::std::string* release_ylabel();
  void set_allocated_ylabel(::std::string* ylabel);

  // string window_title = 4;
  void clear_window_title();
  static const int kWindowTitleFieldNumber = 4;
  const ::std::string& window_title() const;
  void set_window_title(const ::std::string& value);
  #if LANG_CXX11
  void set_window_title(::std::string&& value);
  #endif
  void set_window_title(const char* value);
  void set_window_title(const char* value, size_t size);
  ::std::string* mutable_window_title();
  ::std::string* release_window_title();
  void set_allocated_window_title(::std::string* window_title);

  // string legend = 6;
  void clear_legend();
  static const int kLegendFieldNumber = 6;
  const ::std::string& legend() const;
  void set_legend(const ::std::string& value);
  #if LANG_CXX11
  void set_legend(::std::string&& value);
  #endif
  void set_legend(const char* value);
  void set_legend(const char* value, size_t size);
  ::std::string* mutable_legend();
  ::std::string* release_legend();
  void set_allocated_legend(::std::string* legend);

  // string zoom = 7;
  void clear_zoom();
  static const int kZoomFieldNumber = 7;
  const ::std::string& zoom() const;
  void set_zoom(const ::std::string& value);
  #if LANG_CXX11
  void set_zoom(::std::string&& value);
  #endif
  void set_zoom(const char* value);
  void set_zoom(const char* value, size_t size);
  ::std::string* mutable_zoom();
  ::std::string* release_zoom();
  void set_allocated_zoom(::std::string* zoom);

  // int32 with_panel = 8;
  void clear_with_panel();
  static const int kWithPanelFieldNumber = 8;
  ::google::protobuf::int32 with_panel() const;
  void set_with_panel(::google::protobuf::int32 value);

  // bool new_row = 9;
  void clear_new_row();
  static const int kNewRowFieldNumber = 9;
  bool new_row() const;
  void set_new_row(bool value);

  // bool hidden = 10;
  void clear_hidden();
  static const int kHiddenFieldNumber = 10;
  bool hidden() const;
  void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:rpc.gui.NewPanel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > size_;
  mutable int _size_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr xlabel_;
  ::google::protobuf::internal::ArenaStringPtr ylabel_;
  ::google::protobuf::internal::ArenaStringPtr window_title_;
  ::google::protobuf::internal::ArenaStringPtr legend_;
  ::google::protobuf::internal::ArenaStringPtr zoom_;
  ::google::protobuf::int32 with_panel_;
  bool new_row_;
  bool hidden_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsNewPanelImpl();
};
// -------------------------------------------------------------------

class Colors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.Colors) */ {
 public:
  Colors();
  virtual ~Colors();

  Colors(const Colors& from);

  inline Colors& operator=(const Colors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Colors(Colors&& from) noexcept
    : Colors() {
    *this = ::std::move(from);
  }

  inline Colors& operator=(Colors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Colors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Colors* internal_default_instance() {
    return reinterpret_cast<const Colors*>(
               &_Colors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Colors* other);
  friend void swap(Colors& a, Colors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Colors* New() const PROTOBUF_FINAL { return New(NULL); }

  Colors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Colors& from);
  void MergeFrom(const Colors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Colors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:rpc.gui.Colors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsColorsImpl();
};
// -------------------------------------------------------------------

class ColorMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.ColorMaps) */ {
 public:
  ColorMaps();
  virtual ~ColorMaps();

  ColorMaps(const ColorMaps& from);

  inline ColorMaps& operator=(const ColorMaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColorMaps(ColorMaps&& from) noexcept
    : ColorMaps() {
    *this = ::std::move(from);
  }

  inline ColorMaps& operator=(ColorMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColorMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColorMaps* internal_default_instance() {
    return reinterpret_cast<const ColorMaps*>(
               &_ColorMaps_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ColorMaps* other);
  friend void swap(ColorMaps& a, ColorMaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColorMaps* New() const PROTOBUF_FINAL { return New(NULL); }

  ColorMaps* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColorMaps& from);
  void MergeFrom(const ColorMaps& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColorMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:rpc.gui.ColorMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsColorMapsImpl();
};
// -------------------------------------------------------------------

class Symbols : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.Symbols) */ {
 public:
  Symbols();
  virtual ~Symbols();

  Symbols(const Symbols& from);

  inline Symbols& operator=(const Symbols& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Symbols(Symbols&& from) noexcept
    : Symbols() {
    *this = ::std::move(from);
  }

  inline Symbols& operator=(Symbols&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Symbols& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Symbols* internal_default_instance() {
    return reinterpret_cast<const Symbols*>(
               &_Symbols_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Symbols* other);
  friend void swap(Symbols& a, Symbols& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Symbols* New() const PROTOBUF_FINAL { return New(NULL); }

  Symbols* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Symbols& from);
  void MergeFrom(const Symbols& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Symbols* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:rpc.gui.Symbols)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsSymbolsImpl();
};
// -------------------------------------------------------------------

class NewLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.NewLine) */ {
 public:
  NewLine();
  virtual ~NewLine();

  NewLine(const NewLine& from);

  inline NewLine& operator=(const NewLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewLine(NewLine&& from) noexcept
    : NewLine() {
    *this = ::std::move(from);
  }

  inline NewLine& operator=(NewLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewLine* internal_default_instance() {
    return reinterpret_cast<const NewLine*>(
               &_NewLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(NewLine* other);
  friend void swap(NewLine& a, NewLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewLine* New() const PROTOBUF_FINAL { return New(NULL); }

  NewLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewLine& from);
  void MergeFrom(const NewLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double x = 1;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x(int index) const;
  void set_x(int index, double value);
  void add_x(double value);
  const ::google::protobuf::RepeatedField< double >&
      x() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // repeated double y = 2;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y(int index) const;
  void set_y(int index, double value);
  void add_y(double value);
  const ::google::protobuf::RepeatedField< double >&
      y() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_y();

  // string color = 3;
  void clear_color();
  static const int kColorFieldNumber = 3;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  #if LANG_CXX11
  void set_color(::std::string&& value);
  #endif
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .rpc.gui.Id panel = 5;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 5;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.gui.NewLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::rpc::gui::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsNewLineImpl();
};
// -------------------------------------------------------------------

class NewScatter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.NewScatter) */ {
 public:
  NewScatter();
  virtual ~NewScatter();

  NewScatter(const NewScatter& from);

  inline NewScatter& operator=(const NewScatter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewScatter(NewScatter&& from) noexcept
    : NewScatter() {
    *this = ::std::move(from);
  }

  inline NewScatter& operator=(NewScatter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewScatter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewScatter* internal_default_instance() {
    return reinterpret_cast<const NewScatter*>(
               &_NewScatter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NewScatter* other);
  friend void swap(NewScatter& a, NewScatter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewScatter* New() const PROTOBUF_FINAL { return New(NULL); }

  NewScatter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewScatter& from);
  void MergeFrom(const NewScatter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewScatter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double x = 1;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x(int index) const;
  void set_x(int index, double value);
  void add_x(double value);
  const ::google::protobuf::RepeatedField< double >&
      x() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // repeated double y = 2;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y(int index) const;
  void set_y(int index, double value);
  void add_y(double value);
  const ::google::protobuf::RepeatedField< double >&
      y() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_y();

  // string color = 3;
  void clear_color();
  static const int kColorFieldNumber = 3;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  #if LANG_CXX11
  void set_color(::std::string&& value);
  #endif
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // string symbol = 5;
  void clear_symbol();
  static const int kSymbolFieldNumber = 5;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // .rpc.gui.Id panel = 8;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 8;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // int32 symbol_size = 6;
  void clear_symbol_size();
  static const int kSymbolSizeFieldNumber = 6;
  ::google::protobuf::int32 symbol_size() const;
  void set_symbol_size(::google::protobuf::int32 value);

  // int32 dot_size = 7;
  void clear_dot_size();
  static const int kDotSizeFieldNumber = 7;
  ::google::protobuf::int32 dot_size() const;
  void set_dot_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.NewScatter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::rpc::gui::Id* panel_;
  ::google::protobuf::int32 symbol_size_;
  ::google::protobuf::int32 dot_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsNewScatterImpl();
};
// -------------------------------------------------------------------

class NewHistogram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.NewHistogram) */ {
 public:
  NewHistogram();
  virtual ~NewHistogram();

  NewHistogram(const NewHistogram& from);

  inline NewHistogram& operator=(const NewHistogram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewHistogram(NewHistogram&& from) noexcept
    : NewHistogram() {
    *this = ::std::move(from);
  }

  inline NewHistogram& operator=(NewHistogram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewHistogram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewHistogram* internal_default_instance() {
    return reinterpret_cast<const NewHistogram*>(
               &_NewHistogram_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(NewHistogram* other);
  friend void swap(NewHistogram& a, NewHistogram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewHistogram* New() const PROTOBUF_FINAL { return New(NULL); }

  NewHistogram* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewHistogram& from);
  void MergeFrom(const NewHistogram& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewHistogram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // string color = 3;
  void clear_color();
  static const int kColorFieldNumber = 3;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  #if LANG_CXX11
  void set_color(::std::string&& value);
  #endif
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .rpc.gui.Id panel = 5;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 5;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // int32 bins = 2;
  void clear_bins();
  static const int kBinsFieldNumber = 2;
  ::google::protobuf::int32 bins() const;
  void set_bins(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.NewHistogram)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::rpc::gui::Id* panel_;
  ::google::protobuf::int32 bins_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsNewHistogramImpl();
};
// -------------------------------------------------------------------

class NewRaster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.NewRaster) */ {
 public:
  NewRaster();
  virtual ~NewRaster();

  NewRaster(const NewRaster& from);

  inline NewRaster& operator=(const NewRaster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewRaster(NewRaster&& from) noexcept
    : NewRaster() {
    *this = ::std::move(from);
  }

  inline NewRaster& operator=(NewRaster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewRaster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewRaster* internal_default_instance() {
    return reinterpret_cast<const NewRaster*>(
               &_NewRaster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(NewRaster* other);
  friend void swap(NewRaster& a, NewRaster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewRaster* New() const PROTOBUF_FINAL { return New(NULL); }

  NewRaster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewRaster& from);
  void MergeFrom(const NewRaster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewRaster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double matrix = 1;
  int matrix_size() const;
  void clear_matrix();
  static const int kMatrixFieldNumber = 1;
  double matrix(int index) const;
  void set_matrix(int index, double value);
  void add_matrix(double value);
  const ::google::protobuf::RepeatedField< double >&
      matrix() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_matrix();

  // string colormap = 4;
  void clear_colormap();
  static const int kColormapFieldNumber = 4;
  const ::std::string& colormap() const;
  void set_colormap(const ::std::string& value);
  #if LANG_CXX11
  void set_colormap(::std::string&& value);
  #endif
  void set_colormap(const char* value);
  void set_colormap(const char* value, size_t size);
  ::std::string* mutable_colormap();
  ::std::string* release_colormap();
  void set_allocated_colormap(::std::string* colormap);

  // .rpc.gui.Id panel = 5;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 5;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // int32 sizex = 2;
  void clear_sizex();
  static const int kSizexFieldNumber = 2;
  ::google::protobuf::int32 sizex() const;
  void set_sizex(::google::protobuf::int32 value);

  // int32 sizey = 3;
  void clear_sizey();
  static const int kSizeyFieldNumber = 3;
  ::google::protobuf::int32 sizey() const;
  void set_sizey(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.gui.NewRaster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > matrix_;
  mutable int _matrix_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr colormap_;
  ::rpc::gui::Id* panel_;
  ::google::protobuf::int32 sizex_;
  ::google::protobuf::int32 sizey_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsNewRasterImpl();
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.Label) */ {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Label(Label&& from) noexcept
    : Label() {
    *this = ::std::move(from);
  }

  inline Label& operator=(Label&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Label* internal_default_instance() {
    return reinterpret_cast<const Label*>(
               &_Label_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Label* other);
  friend void swap(Label& a, Label& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Label* New() const PROTOBUF_FINAL { return New(NULL); }

  Label* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Label* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string xlabel = 1;
  void clear_xlabel();
  static const int kXlabelFieldNumber = 1;
  const ::std::string& xlabel() const;
  void set_xlabel(const ::std::string& value);
  #if LANG_CXX11
  void set_xlabel(::std::string&& value);
  #endif
  void set_xlabel(const char* value);
  void set_xlabel(const char* value, size_t size);
  ::std::string* mutable_xlabel();
  ::std::string* release_xlabel();
  void set_allocated_xlabel(::std::string* xlabel);

  // string ylabel = 2;
  void clear_ylabel();
  static const int kYlabelFieldNumber = 2;
  const ::std::string& ylabel() const;
  void set_ylabel(const ::std::string& value);
  #if LANG_CXX11
  void set_ylabel(::std::string&& value);
  #endif
  void set_ylabel(const char* value);
  void set_ylabel(const char* value, size_t size);
  ::std::string* mutable_ylabel();
  ::std::string* release_ylabel();
  void set_allocated_ylabel(::std::string* ylabel);

  // string title = 3;
  void clear_title();
  static const int kTitleFieldNumber = 3;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // .rpc.gui.Id panel = 4;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 4;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.gui.Label)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr xlabel_;
  ::google::protobuf::internal::ArenaStringPtr ylabel_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::rpc::gui::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsLabelImpl();
};
// -------------------------------------------------------------------

class DockSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.gui.DockSpec) */ {
 public:
  DockSpec();
  virtual ~DockSpec();

  DockSpec(const DockSpec& from);

  inline DockSpec& operator=(const DockSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DockSpec(DockSpec&& from) noexcept
    : DockSpec() {
    *this = ::std::move(from);
  }

  inline DockSpec& operator=(DockSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DockSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DockSpec* internal_default_instance() {
    return reinterpret_cast<const DockSpec*>(
               &_DockSpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DockSpec* other);
  friend void swap(DockSpec& a, DockSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DockSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  DockSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DockSpec& from);
  void MergeFrom(const DockSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DockSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dockable = 3;
  int dockable_size() const;
  void clear_dockable();
  static const int kDockableFieldNumber = 3;
  const ::std::string& dockable(int index) const;
  ::std::string* mutable_dockable(int index);
  void set_dockable(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dockable(int index, ::std::string&& value);
  #endif
  void set_dockable(int index, const char* value);
  void set_dockable(int index, const char* value, size_t size);
  ::std::string* add_dockable();
  void add_dockable(const ::std::string& value);
  #if LANG_CXX11
  void add_dockable(::std::string&& value);
  #endif
  void add_dockable(const char* value);
  void add_dockable(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dockable() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dockable();

  // string file_or_xml = 1;
  void clear_file_or_xml();
  static const int kFileOrXmlFieldNumber = 1;
  const ::std::string& file_or_xml() const;
  void set_file_or_xml(const ::std::string& value);
  #if LANG_CXX11
  void set_file_or_xml(::std::string&& value);
  #endif
  void set_file_or_xml(const char* value);
  void set_file_or_xml(const char* value, size_t size);
  ::std::string* mutable_file_or_xml();
  ::std::string* release_file_or_xml();
  void set_allocated_file_or_xml(::std::string* file_or_xml);

  // string loc = 2;
  void clear_loc();
  static const int kLocFieldNumber = 2;
  const ::std::string& loc() const;
  void set_loc(const ::std::string& value);
  #if LANG_CXX11
  void set_loc(::std::string&& value);
  #endif
  void set_loc(const char* value);
  void set_loc(const char* value, size_t size);
  ::std::string* mutable_loc();
  ::std::string* release_loc();
  void set_allocated_loc(::std::string* loc);

  // .rpc.gui.Id panel = 4;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 4;
  const ::rpc::gui::Id& panel() const;
  ::rpc::gui::Id* release_panel();
  ::rpc::gui::Id* mutable_panel();
  void set_allocated_panel(::rpc::gui::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.gui.DockSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dockable_;
  ::google::protobuf::internal::ArenaStringPtr file_or_xml_;
  ::google::protobuf::internal::ArenaStringPtr loc_;
  ::rpc::gui::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_plotserver_2eproto::TableStruct;
  friend void ::protobuf_plotserver_2eproto::InitDefaultsDockSpecImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Id

// int32 id = 1;
inline void Id::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Id::id() const {
  // @@protoc_insertion_point(field_get:rpc.gui.Id.id)
  return id_;
}
inline void Id::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.Id.id)
}

// -------------------------------------------------------------------

// NewPanel

// string title = 1;
inline void NewPanel::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::title() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.title)
  return title_.GetNoArena();
}
inline void NewPanel::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.title)
}
#if LANG_CXX11
inline void NewPanel::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.title)
}
#endif
inline void NewPanel::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.title)
}
inline void NewPanel::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.title)
}
inline ::std::string* NewPanel::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_title() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.title)
}

// string xlabel = 2;
inline void NewPanel::clear_xlabel() {
  xlabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::xlabel() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.xlabel)
  return xlabel_.GetNoArena();
}
inline void NewPanel::set_xlabel(const ::std::string& value) {
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.xlabel)
}
#if LANG_CXX11
inline void NewPanel::set_xlabel(::std::string&& value) {
  
  xlabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.xlabel)
}
#endif
inline void NewPanel::set_xlabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.xlabel)
}
inline void NewPanel::set_xlabel(const char* value, size_t size) {
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.xlabel)
}
inline ::std::string* NewPanel::mutable_xlabel() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.xlabel)
  return xlabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_xlabel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.xlabel)
  
  return xlabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_xlabel(::std::string* xlabel) {
  if (xlabel != NULL) {
    
  } else {
    
  }
  xlabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xlabel);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.xlabel)
}

// string ylabel = 3;
inline void NewPanel::clear_ylabel() {
  ylabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::ylabel() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.ylabel)
  return ylabel_.GetNoArena();
}
inline void NewPanel::set_ylabel(const ::std::string& value) {
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.ylabel)
}
#if LANG_CXX11
inline void NewPanel::set_ylabel(::std::string&& value) {
  
  ylabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.ylabel)
}
#endif
inline void NewPanel::set_ylabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.ylabel)
}
inline void NewPanel::set_ylabel(const char* value, size_t size) {
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.ylabel)
}
inline ::std::string* NewPanel::mutable_ylabel() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.ylabel)
  return ylabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_ylabel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.ylabel)
  
  return ylabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_ylabel(::std::string* ylabel) {
  if (ylabel != NULL) {
    
  } else {
    
  }
  ylabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ylabel);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.ylabel)
}

// string window_title = 4;
inline void NewPanel::clear_window_title() {
  window_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::window_title() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.window_title)
  return window_title_.GetNoArena();
}
inline void NewPanel::set_window_title(const ::std::string& value) {
  
  window_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.window_title)
}
#if LANG_CXX11
inline void NewPanel::set_window_title(::std::string&& value) {
  
  window_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.window_title)
}
#endif
inline void NewPanel::set_window_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  window_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.window_title)
}
inline void NewPanel::set_window_title(const char* value, size_t size) {
  
  window_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.window_title)
}
inline ::std::string* NewPanel::mutable_window_title() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.window_title)
  return window_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_window_title() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.window_title)
  
  return window_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_window_title(::std::string* window_title) {
  if (window_title != NULL) {
    
  } else {
    
  }
  window_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), window_title);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.window_title)
}

// repeated int32 size = 5;
inline int NewPanel::size_size() const {
  return size_.size();
}
inline void NewPanel::clear_size() {
  size_.Clear();
}
inline ::google::protobuf::int32 NewPanel::size(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.size)
  return size_.Get(index);
}
inline void NewPanel::set_size(int index, ::google::protobuf::int32 value) {
  size_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.size)
}
inline void NewPanel::add_size(::google::protobuf::int32 value) {
  size_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewPanel.size)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NewPanel::size() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewPanel.size)
  return size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NewPanel::mutable_size() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewPanel.size)
  return &size_;
}

// string legend = 6;
inline void NewPanel::clear_legend() {
  legend_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::legend() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.legend)
  return legend_.GetNoArena();
}
inline void NewPanel::set_legend(const ::std::string& value) {
  
  legend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.legend)
}
#if LANG_CXX11
inline void NewPanel::set_legend(::std::string&& value) {
  
  legend_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.legend)
}
#endif
inline void NewPanel::set_legend(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  legend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.legend)
}
inline void NewPanel::set_legend(const char* value, size_t size) {
  
  legend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.legend)
}
inline ::std::string* NewPanel::mutable_legend() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.legend)
  return legend_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_legend() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.legend)
  
  return legend_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_legend(::std::string* legend) {
  if (legend != NULL) {
    
  } else {
    
  }
  legend_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legend);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.legend)
}

// string zoom = 7;
inline void NewPanel::clear_zoom() {
  zoom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::zoom() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.zoom)
  return zoom_.GetNoArena();
}
inline void NewPanel::set_zoom(const ::std::string& value) {
  
  zoom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.zoom)
}
#if LANG_CXX11
inline void NewPanel::set_zoom(::std::string&& value) {
  
  zoom_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewPanel.zoom)
}
#endif
inline void NewPanel::set_zoom(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  zoom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewPanel.zoom)
}
inline void NewPanel::set_zoom(const char* value, size_t size) {
  
  zoom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewPanel.zoom)
}
inline ::std::string* NewPanel::mutable_zoom() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewPanel.zoom)
  return zoom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_zoom() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewPanel.zoom)
  
  return zoom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_zoom(::std::string* zoom) {
  if (zoom != NULL) {
    
  } else {
    
  }
  zoom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zoom);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewPanel.zoom)
}

// int32 with_panel = 8;
inline void NewPanel::clear_with_panel() {
  with_panel_ = 0;
}
inline ::google::protobuf::int32 NewPanel::with_panel() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.with_panel)
  return with_panel_;
}
inline void NewPanel::set_with_panel(::google::protobuf::int32 value) {
  
  with_panel_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.with_panel)
}

// bool new_row = 9;
inline void NewPanel::clear_new_row() {
  new_row_ = false;
}
inline bool NewPanel::new_row() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.new_row)
  return new_row_;
}
inline void NewPanel::set_new_row(bool value) {
  
  new_row_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.new_row)
}

// bool hidden = 10;
inline void NewPanel::clear_hidden() {
  hidden_ = false;
}
inline bool NewPanel::hidden() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewPanel.hidden)
  return hidden_;
}
inline void NewPanel::set_hidden(bool value) {
  
  hidden_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewPanel.hidden)
}

// -------------------------------------------------------------------

// Colors

// repeated string names = 1;
inline int Colors::names_size() const {
  return names_.size();
}
inline void Colors::clear_names() {
  names_.Clear();
}
inline const ::std::string& Colors::names(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.Colors.names)
  return names_.Get(index);
}
inline ::std::string* Colors::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:rpc.gui.Colors.names)
  return names_.Mutable(index);
}
inline void Colors::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.Colors.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Colors::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.Colors.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Colors::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc.gui.Colors.names)
}
inline void Colors::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.Colors.names)
}
inline ::std::string* Colors::add_names() {
  // @@protoc_insertion_point(field_add_mutable:rpc.gui.Colors.names)
  return names_.Add();
}
inline void Colors::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc.gui.Colors.names)
}
#if LANG_CXX11
inline void Colors::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc.gui.Colors.names)
}
#endif
inline void Colors::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc.gui.Colors.names)
}
inline void Colors::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc.gui.Colors.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Colors::names() const {
  // @@protoc_insertion_point(field_list:rpc.gui.Colors.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Colors::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.Colors.names)
  return &names_;
}

// -------------------------------------------------------------------

// ColorMaps

// repeated string names = 1;
inline int ColorMaps::names_size() const {
  return names_.size();
}
inline void ColorMaps::clear_names() {
  names_.Clear();
}
inline const ::std::string& ColorMaps::names(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.ColorMaps.names)
  return names_.Get(index);
}
inline ::std::string* ColorMaps::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:rpc.gui.ColorMaps.names)
  return names_.Mutable(index);
}
inline void ColorMaps::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.ColorMaps.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ColorMaps::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.ColorMaps.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ColorMaps::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc.gui.ColorMaps.names)
}
inline void ColorMaps::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.ColorMaps.names)
}
inline ::std::string* ColorMaps::add_names() {
  // @@protoc_insertion_point(field_add_mutable:rpc.gui.ColorMaps.names)
  return names_.Add();
}
inline void ColorMaps::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc.gui.ColorMaps.names)
}
#if LANG_CXX11
inline void ColorMaps::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc.gui.ColorMaps.names)
}
#endif
inline void ColorMaps::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc.gui.ColorMaps.names)
}
inline void ColorMaps::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc.gui.ColorMaps.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ColorMaps::names() const {
  // @@protoc_insertion_point(field_list:rpc.gui.ColorMaps.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ColorMaps::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.ColorMaps.names)
  return &names_;
}

// -------------------------------------------------------------------

// Symbols

// repeated string names = 1;
inline int Symbols::names_size() const {
  return names_.size();
}
inline void Symbols::clear_names() {
  names_.Clear();
}
inline const ::std::string& Symbols::names(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.Symbols.names)
  return names_.Get(index);
}
inline ::std::string* Symbols::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:rpc.gui.Symbols.names)
  return names_.Mutable(index);
}
inline void Symbols::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.Symbols.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Symbols::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.Symbols.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Symbols::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc.gui.Symbols.names)
}
inline void Symbols::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.Symbols.names)
}
inline ::std::string* Symbols::add_names() {
  // @@protoc_insertion_point(field_add_mutable:rpc.gui.Symbols.names)
  return names_.Add();
}
inline void Symbols::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc.gui.Symbols.names)
}
#if LANG_CXX11
inline void Symbols::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc.gui.Symbols.names)
}
#endif
inline void Symbols::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc.gui.Symbols.names)
}
inline void Symbols::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc.gui.Symbols.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Symbols::names() const {
  // @@protoc_insertion_point(field_list:rpc.gui.Symbols.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Symbols::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.Symbols.names)
  return &names_;
}

// -------------------------------------------------------------------

// NewLine

// repeated double x = 1;
inline int NewLine::x_size() const {
  return x_.size();
}
inline void NewLine::clear_x() {
  x_.Clear();
}
inline double NewLine::x(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewLine.x)
  return x_.Get(index);
}
inline void NewLine::set_x(int index, double value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewLine.x)
}
inline void NewLine::add_x(double value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewLine.x)
}
inline const ::google::protobuf::RepeatedField< double >&
NewLine::x() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewLine.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
NewLine::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewLine.x)
  return &x_;
}

// repeated double y = 2;
inline int NewLine::y_size() const {
  return y_.size();
}
inline void NewLine::clear_y() {
  y_.Clear();
}
inline double NewLine::y(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewLine.y)
  return y_.Get(index);
}
inline void NewLine::set_y(int index, double value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewLine.y)
}
inline void NewLine::add_y(double value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewLine.y)
}
inline const ::google::protobuf::RepeatedField< double >&
NewLine::y() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewLine.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< double >*
NewLine::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewLine.y)
  return &y_;
}

// string color = 3;
inline void NewLine::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewLine::color() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewLine.color)
  return color_.GetNoArena();
}
inline void NewLine::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewLine.color)
}
#if LANG_CXX11
inline void NewLine::set_color(::std::string&& value) {
  
  color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewLine.color)
}
#endif
inline void NewLine::set_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewLine.color)
}
inline void NewLine::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewLine.color)
}
inline ::std::string* NewLine::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewLine.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewLine::release_color() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewLine.color)
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewLine::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewLine.color)
}

// string label = 4;
inline void NewLine::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewLine::label() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewLine.label)
  return label_.GetNoArena();
}
inline void NewLine::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewLine.label)
}
#if LANG_CXX11
inline void NewLine::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewLine.label)
}
#endif
inline void NewLine::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewLine.label)
}
inline void NewLine::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewLine.label)
}
inline ::std::string* NewLine::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewLine.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewLine::release_label() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewLine.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewLine::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewLine.label)
}

// .rpc.gui.Id panel = 5;
inline bool NewLine::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void NewLine::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& NewLine::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.NewLine.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* NewLine::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewLine.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* NewLine::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewLine.panel)
  return panel_;
}
inline void NewLine::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewLine.panel)
}

// -------------------------------------------------------------------

// NewScatter

// repeated double x = 1;
inline int NewScatter::x_size() const {
  return x_.size();
}
inline void NewScatter::clear_x() {
  x_.Clear();
}
inline double NewScatter::x(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.x)
  return x_.Get(index);
}
inline void NewScatter::set_x(int index, double value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.x)
}
inline void NewScatter::add_x(double value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewScatter.x)
}
inline const ::google::protobuf::RepeatedField< double >&
NewScatter::x() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewScatter.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
NewScatter::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewScatter.x)
  return &x_;
}

// repeated double y = 2;
inline int NewScatter::y_size() const {
  return y_.size();
}
inline void NewScatter::clear_y() {
  y_.Clear();
}
inline double NewScatter::y(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.y)
  return y_.Get(index);
}
inline void NewScatter::set_y(int index, double value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.y)
}
inline void NewScatter::add_y(double value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewScatter.y)
}
inline const ::google::protobuf::RepeatedField< double >&
NewScatter::y() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewScatter.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< double >*
NewScatter::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewScatter.y)
  return &y_;
}

// string color = 3;
inline void NewScatter::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewScatter::color() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.color)
  return color_.GetNoArena();
}
inline void NewScatter::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.color)
}
#if LANG_CXX11
inline void NewScatter::set_color(::std::string&& value) {
  
  color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewScatter.color)
}
#endif
inline void NewScatter::set_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewScatter.color)
}
inline void NewScatter::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewScatter.color)
}
inline ::std::string* NewScatter::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewScatter.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewScatter::release_color() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewScatter.color)
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewScatter::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewScatter.color)
}

// string label = 4;
inline void NewScatter::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewScatter::label() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.label)
  return label_.GetNoArena();
}
inline void NewScatter::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.label)
}
#if LANG_CXX11
inline void NewScatter::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewScatter.label)
}
#endif
inline void NewScatter::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewScatter.label)
}
inline void NewScatter::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewScatter.label)
}
inline ::std::string* NewScatter::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewScatter.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewScatter::release_label() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewScatter.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewScatter::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewScatter.label)
}

// string symbol = 5;
inline void NewScatter::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewScatter::symbol() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.symbol)
  return symbol_.GetNoArena();
}
inline void NewScatter::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.symbol)
}
#if LANG_CXX11
inline void NewScatter::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewScatter.symbol)
}
#endif
inline void NewScatter::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewScatter.symbol)
}
inline void NewScatter::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewScatter.symbol)
}
inline ::std::string* NewScatter::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewScatter.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewScatter::release_symbol() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewScatter.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewScatter::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewScatter.symbol)
}

// int32 symbol_size = 6;
inline void NewScatter::clear_symbol_size() {
  symbol_size_ = 0;
}
inline ::google::protobuf::int32 NewScatter::symbol_size() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.symbol_size)
  return symbol_size_;
}
inline void NewScatter::set_symbol_size(::google::protobuf::int32 value) {
  
  symbol_size_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.symbol_size)
}

// int32 dot_size = 7;
inline void NewScatter::clear_dot_size() {
  dot_size_ = 0;
}
inline ::google::protobuf::int32 NewScatter::dot_size() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.dot_size)
  return dot_size_;
}
inline void NewScatter::set_dot_size(::google::protobuf::int32 value) {
  
  dot_size_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewScatter.dot_size)
}

// .rpc.gui.Id panel = 8;
inline bool NewScatter::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void NewScatter::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& NewScatter::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.NewScatter.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* NewScatter::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewScatter.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* NewScatter::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewScatter.panel)
  return panel_;
}
inline void NewScatter::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewScatter.panel)
}

// -------------------------------------------------------------------

// NewHistogram

// repeated double values = 1;
inline int NewHistogram::values_size() const {
  return values_.size();
}
inline void NewHistogram::clear_values() {
  values_.Clear();
}
inline double NewHistogram::values(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewHistogram.values)
  return values_.Get(index);
}
inline void NewHistogram::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewHistogram.values)
}
inline void NewHistogram::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewHistogram.values)
}
inline const ::google::protobuf::RepeatedField< double >&
NewHistogram::values() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewHistogram.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
NewHistogram::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewHistogram.values)
  return &values_;
}

// int32 bins = 2;
inline void NewHistogram::clear_bins() {
  bins_ = 0;
}
inline ::google::protobuf::int32 NewHistogram::bins() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewHistogram.bins)
  return bins_;
}
inline void NewHistogram::set_bins(::google::protobuf::int32 value) {
  
  bins_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewHistogram.bins)
}

// string color = 3;
inline void NewHistogram::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewHistogram::color() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewHistogram.color)
  return color_.GetNoArena();
}
inline void NewHistogram::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewHistogram.color)
}
#if LANG_CXX11
inline void NewHistogram::set_color(::std::string&& value) {
  
  color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewHistogram.color)
}
#endif
inline void NewHistogram::set_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewHistogram.color)
}
inline void NewHistogram::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewHistogram.color)
}
inline ::std::string* NewHistogram::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewHistogram.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewHistogram::release_color() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewHistogram.color)
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewHistogram::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewHistogram.color)
}

// string label = 4;
inline void NewHistogram::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewHistogram::label() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewHistogram.label)
  return label_.GetNoArena();
}
inline void NewHistogram::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewHistogram.label)
}
#if LANG_CXX11
inline void NewHistogram::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewHistogram.label)
}
#endif
inline void NewHistogram::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewHistogram.label)
}
inline void NewHistogram::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewHistogram.label)
}
inline ::std::string* NewHistogram::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewHistogram.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewHistogram::release_label() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewHistogram.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewHistogram::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewHistogram.label)
}

// .rpc.gui.Id panel = 5;
inline bool NewHistogram::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void NewHistogram::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& NewHistogram::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.NewHistogram.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* NewHistogram::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewHistogram.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* NewHistogram::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewHistogram.panel)
  return panel_;
}
inline void NewHistogram::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewHistogram.panel)
}

// -------------------------------------------------------------------

// NewRaster

// repeated double matrix = 1;
inline int NewRaster::matrix_size() const {
  return matrix_.size();
}
inline void NewRaster::clear_matrix() {
  matrix_.Clear();
}
inline double NewRaster::matrix(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewRaster.matrix)
  return matrix_.Get(index);
}
inline void NewRaster::set_matrix(int index, double value) {
  matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewRaster.matrix)
}
inline void NewRaster::add_matrix(double value) {
  matrix_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.gui.NewRaster.matrix)
}
inline const ::google::protobuf::RepeatedField< double >&
NewRaster::matrix() const {
  // @@protoc_insertion_point(field_list:rpc.gui.NewRaster.matrix)
  return matrix_;
}
inline ::google::protobuf::RepeatedField< double >*
NewRaster::mutable_matrix() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.NewRaster.matrix)
  return &matrix_;
}

// int32 sizex = 2;
inline void NewRaster::clear_sizex() {
  sizex_ = 0;
}
inline ::google::protobuf::int32 NewRaster::sizex() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewRaster.sizex)
  return sizex_;
}
inline void NewRaster::set_sizex(::google::protobuf::int32 value) {
  
  sizex_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewRaster.sizex)
}

// int32 sizey = 3;
inline void NewRaster::clear_sizey() {
  sizey_ = 0;
}
inline ::google::protobuf::int32 NewRaster::sizey() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewRaster.sizey)
  return sizey_;
}
inline void NewRaster::set_sizey(::google::protobuf::int32 value) {
  
  sizey_ = value;
  // @@protoc_insertion_point(field_set:rpc.gui.NewRaster.sizey)
}

// string colormap = 4;
inline void NewRaster::clear_colormap() {
  colormap_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewRaster::colormap() const {
  // @@protoc_insertion_point(field_get:rpc.gui.NewRaster.colormap)
  return colormap_.GetNoArena();
}
inline void NewRaster::set_colormap(const ::std::string& value) {
  
  colormap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.NewRaster.colormap)
}
#if LANG_CXX11
inline void NewRaster::set_colormap(::std::string&& value) {
  
  colormap_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.NewRaster.colormap)
}
#endif
inline void NewRaster::set_colormap(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  colormap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.NewRaster.colormap)
}
inline void NewRaster::set_colormap(const char* value, size_t size) {
  
  colormap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.NewRaster.colormap)
}
inline ::std::string* NewRaster::mutable_colormap() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewRaster.colormap)
  return colormap_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRaster::release_colormap() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewRaster.colormap)
  
  return colormap_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRaster::set_allocated_colormap(::std::string* colormap) {
  if (colormap != NULL) {
    
  } else {
    
  }
  colormap_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), colormap);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewRaster.colormap)
}

// .rpc.gui.Id panel = 5;
inline bool NewRaster::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void NewRaster::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& NewRaster::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.NewRaster.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* NewRaster::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.NewRaster.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* NewRaster::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.NewRaster.panel)
  return panel_;
}
inline void NewRaster::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.NewRaster.panel)
}

// -------------------------------------------------------------------

// Label

// string xlabel = 1;
inline void Label::clear_xlabel() {
  xlabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Label::xlabel() const {
  // @@protoc_insertion_point(field_get:rpc.gui.Label.xlabel)
  return xlabel_.GetNoArena();
}
inline void Label::set_xlabel(const ::std::string& value) {
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.Label.xlabel)
}
#if LANG_CXX11
inline void Label::set_xlabel(::std::string&& value) {
  
  xlabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.Label.xlabel)
}
#endif
inline void Label::set_xlabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.Label.xlabel)
}
inline void Label::set_xlabel(const char* value, size_t size) {
  
  xlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.Label.xlabel)
}
inline ::std::string* Label::mutable_xlabel() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.Label.xlabel)
  return xlabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Label::release_xlabel() {
  // @@protoc_insertion_point(field_release:rpc.gui.Label.xlabel)
  
  return xlabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Label::set_allocated_xlabel(::std::string* xlabel) {
  if (xlabel != NULL) {
    
  } else {
    
  }
  xlabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xlabel);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.Label.xlabel)
}

// string ylabel = 2;
inline void Label::clear_ylabel() {
  ylabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Label::ylabel() const {
  // @@protoc_insertion_point(field_get:rpc.gui.Label.ylabel)
  return ylabel_.GetNoArena();
}
inline void Label::set_ylabel(const ::std::string& value) {
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.Label.ylabel)
}
#if LANG_CXX11
inline void Label::set_ylabel(::std::string&& value) {
  
  ylabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.Label.ylabel)
}
#endif
inline void Label::set_ylabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.Label.ylabel)
}
inline void Label::set_ylabel(const char* value, size_t size) {
  
  ylabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.Label.ylabel)
}
inline ::std::string* Label::mutable_ylabel() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.Label.ylabel)
  return ylabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Label::release_ylabel() {
  // @@protoc_insertion_point(field_release:rpc.gui.Label.ylabel)
  
  return ylabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Label::set_allocated_ylabel(::std::string* ylabel) {
  if (ylabel != NULL) {
    
  } else {
    
  }
  ylabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ylabel);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.Label.ylabel)
}

// string title = 3;
inline void Label::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Label::title() const {
  // @@protoc_insertion_point(field_get:rpc.gui.Label.title)
  return title_.GetNoArena();
}
inline void Label::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.Label.title)
}
#if LANG_CXX11
inline void Label::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.Label.title)
}
#endif
inline void Label::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.Label.title)
}
inline void Label::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.Label.title)
}
inline ::std::string* Label::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.Label.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Label::release_title() {
  // @@protoc_insertion_point(field_release:rpc.gui.Label.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Label::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.Label.title)
}

// .rpc.gui.Id panel = 4;
inline bool Label::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void Label::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& Label::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.Label.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* Label::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.Label.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* Label::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.Label.panel)
  return panel_;
}
inline void Label::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.Label.panel)
}

// -------------------------------------------------------------------

// DockSpec

// string file_or_xml = 1;
inline void DockSpec::clear_file_or_xml() {
  file_or_xml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DockSpec::file_or_xml() const {
  // @@protoc_insertion_point(field_get:rpc.gui.DockSpec.file_or_xml)
  return file_or_xml_.GetNoArena();
}
inline void DockSpec::set_file_or_xml(const ::std::string& value) {
  
  file_or_xml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.DockSpec.file_or_xml)
}
#if LANG_CXX11
inline void DockSpec::set_file_or_xml(::std::string&& value) {
  
  file_or_xml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.DockSpec.file_or_xml)
}
#endif
inline void DockSpec::set_file_or_xml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_or_xml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.DockSpec.file_or_xml)
}
inline void DockSpec::set_file_or_xml(const char* value, size_t size) {
  
  file_or_xml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.DockSpec.file_or_xml)
}
inline ::std::string* DockSpec::mutable_file_or_xml() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.DockSpec.file_or_xml)
  return file_or_xml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DockSpec::release_file_or_xml() {
  // @@protoc_insertion_point(field_release:rpc.gui.DockSpec.file_or_xml)
  
  return file_or_xml_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DockSpec::set_allocated_file_or_xml(::std::string* file_or_xml) {
  if (file_or_xml != NULL) {
    
  } else {
    
  }
  file_or_xml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_or_xml);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.DockSpec.file_or_xml)
}

// string loc = 2;
inline void DockSpec::clear_loc() {
  loc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DockSpec::loc() const {
  // @@protoc_insertion_point(field_get:rpc.gui.DockSpec.loc)
  return loc_.GetNoArena();
}
inline void DockSpec::set_loc(const ::std::string& value) {
  
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.gui.DockSpec.loc)
}
#if LANG_CXX11
inline void DockSpec::set_loc(::std::string&& value) {
  
  loc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.gui.DockSpec.loc)
}
#endif
inline void DockSpec::set_loc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.gui.DockSpec.loc)
}
inline void DockSpec::set_loc(const char* value, size_t size) {
  
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.DockSpec.loc)
}
inline ::std::string* DockSpec::mutable_loc() {
  
  // @@protoc_insertion_point(field_mutable:rpc.gui.DockSpec.loc)
  return loc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DockSpec::release_loc() {
  // @@protoc_insertion_point(field_release:rpc.gui.DockSpec.loc)
  
  return loc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DockSpec::set_allocated_loc(::std::string* loc) {
  if (loc != NULL) {
    
  } else {
    
  }
  loc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), loc);
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.DockSpec.loc)
}

// repeated string dockable = 3;
inline int DockSpec::dockable_size() const {
  return dockable_.size();
}
inline void DockSpec::clear_dockable() {
  dockable_.Clear();
}
inline const ::std::string& DockSpec::dockable(int index) const {
  // @@protoc_insertion_point(field_get:rpc.gui.DockSpec.dockable)
  return dockable_.Get(index);
}
inline ::std::string* DockSpec::mutable_dockable(int index) {
  // @@protoc_insertion_point(field_mutable:rpc.gui.DockSpec.dockable)
  return dockable_.Mutable(index);
}
inline void DockSpec::set_dockable(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.DockSpec.dockable)
  dockable_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DockSpec::set_dockable(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpc.gui.DockSpec.dockable)
  dockable_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DockSpec::set_dockable(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dockable_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpc.gui.DockSpec.dockable)
}
inline void DockSpec::set_dockable(int index, const char* value, size_t size) {
  dockable_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpc.gui.DockSpec.dockable)
}
inline ::std::string* DockSpec::add_dockable() {
  // @@protoc_insertion_point(field_add_mutable:rpc.gui.DockSpec.dockable)
  return dockable_.Add();
}
inline void DockSpec::add_dockable(const ::std::string& value) {
  dockable_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpc.gui.DockSpec.dockable)
}
#if LANG_CXX11
inline void DockSpec::add_dockable(::std::string&& value) {
  dockable_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpc.gui.DockSpec.dockable)
}
#endif
inline void DockSpec::add_dockable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dockable_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpc.gui.DockSpec.dockable)
}
inline void DockSpec::add_dockable(const char* value, size_t size) {
  dockable_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpc.gui.DockSpec.dockable)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DockSpec::dockable() const {
  // @@protoc_insertion_point(field_list:rpc.gui.DockSpec.dockable)
  return dockable_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DockSpec::mutable_dockable() {
  // @@protoc_insertion_point(field_mutable_list:rpc.gui.DockSpec.dockable)
  return &dockable_;
}

// .rpc.gui.Id panel = 4;
inline bool DockSpec::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void DockSpec::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::gui::Id& DockSpec::panel() const {
  const ::rpc::gui::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.gui.DockSpec.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::gui::Id*>(
      &::rpc::gui::_Id_default_instance_);
}
inline ::rpc::gui::Id* DockSpec::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.gui.DockSpec.panel)
  
  ::rpc::gui::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::gui::Id* DockSpec::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::gui::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.gui.DockSpec.panel)
  return panel_;
}
inline void DockSpec::set_allocated_panel(::rpc::gui::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.gui.DockSpec.panel)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gui
}  // namespace rpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_plotserver_2eproto__INCLUDED
