// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: img.proto

#ifndef PROTOBUF_img_2eproto__INCLUDED
#define PROTOBUF_img_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_img_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsIdImpl();
void InitDefaultsId();
void InitDefaultsNewPanelImpl();
void InitDefaultsNewPanel();
void InitDefaultsNewDataImpl();
void InitDefaultsNewData();
void InitDefaultsPopUpImpl();
void InitDefaultsPopUp();
void InitDefaultsRestoreImpl();
void InitDefaultsRestore();
void InitDefaultsFileInfoImpl();
void InitDefaultsFileInfo();
void InitDefaultsKeyInfoImpl();
void InitDefaultsKeyInfo();
void InitDefaultsPathImpl();
void InitDefaultsPath();
void InitDefaultsCoord2DImpl();
void InitDefaultsCoord2D();
void InitDefaultsOutputImpl();
void InitDefaultsOutput();
void InitDefaultsSetChannelImpl();
void InitDefaultsSetChannel();
void InitDefaultsSetZoomLevelImpl();
void InitDefaultsSetZoomLevel();
void InitDefaultsSetZoomBoxImpl();
void InitDefaultsSetZoomBox();
void InitDefaultsDataRangeImpl();
void InitDefaultsDataRange();
void InitDefaultsContourLevelsImpl();
void InitDefaultsContourLevels();
void InitDefaultsContourThicknessImpl();
void InitDefaultsContourThickness();
void InitDefaultsContourColorImpl();
void InitDefaultsContourColor();
void InitDefaultsAxesImpl();
void InitDefaultsAxes();
void InitDefaultsColorMapImpl();
void InitDefaultsColorMap();
void InitDefaultsToggleImpl();
void InitDefaultsToggle();
void InitDefaultsInteractiveMaskOptionsImpl();
void InitDefaultsInteractiveMaskOptions();
void InitDefaultsInteractiveMaskResultImpl();
void InitDefaultsInteractiveMaskResult();
inline void InitDefaults() {
  InitDefaultsId();
  InitDefaultsNewPanel();
  InitDefaultsNewData();
  InitDefaultsPopUp();
  InitDefaultsRestore();
  InitDefaultsFileInfo();
  InitDefaultsKeyInfo();
  InitDefaultsPath();
  InitDefaultsCoord2D();
  InitDefaultsOutput();
  InitDefaultsSetChannel();
  InitDefaultsSetZoomLevel();
  InitDefaultsSetZoomBox();
  InitDefaultsDataRange();
  InitDefaultsContourLevels();
  InitDefaultsContourThickness();
  InitDefaultsContourColor();
  InitDefaultsAxes();
  InitDefaultsColorMap();
  InitDefaultsToggle();
  InitDefaultsInteractiveMaskOptions();
  InitDefaultsInteractiveMaskResult();
}
}  // namespace protobuf_img_2eproto
namespace rpc {
namespace img {
class Axes;
class AxesDefaultTypeInternal;
extern AxesDefaultTypeInternal _Axes_default_instance_;
class ColorMap;
class ColorMapDefaultTypeInternal;
extern ColorMapDefaultTypeInternal _ColorMap_default_instance_;
class ContourColor;
class ContourColorDefaultTypeInternal;
extern ContourColorDefaultTypeInternal _ContourColor_default_instance_;
class ContourLevels;
class ContourLevelsDefaultTypeInternal;
extern ContourLevelsDefaultTypeInternal _ContourLevels_default_instance_;
class ContourThickness;
class ContourThicknessDefaultTypeInternal;
extern ContourThicknessDefaultTypeInternal _ContourThickness_default_instance_;
class Coord2D;
class Coord2DDefaultTypeInternal;
extern Coord2DDefaultTypeInternal _Coord2D_default_instance_;
class DataRange;
class DataRangeDefaultTypeInternal;
extern DataRangeDefaultTypeInternal _DataRange_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class InteractiveMaskOptions;
class InteractiveMaskOptionsDefaultTypeInternal;
extern InteractiveMaskOptionsDefaultTypeInternal _InteractiveMaskOptions_default_instance_;
class InteractiveMaskResult;
class InteractiveMaskResultDefaultTypeInternal;
extern InteractiveMaskResultDefaultTypeInternal _InteractiveMaskResult_default_instance_;
class KeyInfo;
class KeyInfoDefaultTypeInternal;
extern KeyInfoDefaultTypeInternal _KeyInfo_default_instance_;
class NewData;
class NewDataDefaultTypeInternal;
extern NewDataDefaultTypeInternal _NewData_default_instance_;
class NewPanel;
class NewPanelDefaultTypeInternal;
extern NewPanelDefaultTypeInternal _NewPanel_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PopUp;
class PopUpDefaultTypeInternal;
extern PopUpDefaultTypeInternal _PopUp_default_instance_;
class Restore;
class RestoreDefaultTypeInternal;
extern RestoreDefaultTypeInternal _Restore_default_instance_;
class SetChannel;
class SetChannelDefaultTypeInternal;
extern SetChannelDefaultTypeInternal _SetChannel_default_instance_;
class SetZoomBox;
class SetZoomBoxDefaultTypeInternal;
extern SetZoomBoxDefaultTypeInternal _SetZoomBox_default_instance_;
class SetZoomLevel;
class SetZoomLevelDefaultTypeInternal;
extern SetZoomLevelDefaultTypeInternal _SetZoomLevel_default_instance_;
class Toggle;
class ToggleDefaultTypeInternal;
extern ToggleDefaultTypeInternal _Toggle_default_instance_;
}  // namespace img
}  // namespace rpc
namespace rpc {
namespace img {

// ===================================================================

class Id : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Id) */ {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(Id&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Id& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Id* other);
  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Id* New() const PROTOBUF_FINAL { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.img.Id)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsIdImpl();
};
// -------------------------------------------------------------------

class NewPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.NewPanel) */ {
 public:
  NewPanel();
  virtual ~NewPanel();

  NewPanel(const NewPanel& from);

  inline NewPanel& operator=(const NewPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewPanel(NewPanel&& from) noexcept
    : NewPanel() {
    *this = ::std::move(from);
  }

  inline NewPanel& operator=(NewPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewPanel* internal_default_instance() {
    return reinterpret_cast<const NewPanel*>(
               &_NewPanel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NewPanel* other);
  friend void swap(NewPanel& a, NewPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewPanel* New() const PROTOBUF_FINAL { return New(NULL); }

  NewPanel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewPanel& from);
  void MergeFrom(const NewPanel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bool hidden = 2;
  void clear_hidden();
  static const int kHiddenFieldNumber = 2;
  bool hidden() const;
  void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:rpc.img.NewPanel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  bool hidden_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsNewPanelImpl();
};
// -------------------------------------------------------------------

class NewData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.NewData) */ {
 public:
  NewData();
  virtual ~NewData();

  NewData(const NewData& from);

  inline NewData& operator=(const NewData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewData(NewData&& from) noexcept
    : NewData() {
    *this = ::std::move(from);
  }

  inline NewData& operator=(NewData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewData* internal_default_instance() {
    return reinterpret_cast<const NewData*>(
               &_NewData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NewData* other);
  friend void swap(NewData& a, NewData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewData* New() const PROTOBUF_FINAL { return New(NULL); }

  NewData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewData& from);
  void MergeFrom(const NewData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // float scale = 4;
  void clear_scale();
  static const int kScaleFieldNumber = 4;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:rpc.img.NewData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::rpc::img::Id* panel_;
  float scale_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsNewDataImpl();
};
// -------------------------------------------------------------------

class PopUp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.PopUp) */ {
 public:
  PopUp();
  virtual ~PopUp();

  PopUp(const PopUp& from);

  inline PopUp& operator=(const PopUp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PopUp(PopUp&& from) noexcept
    : PopUp() {
    *this = ::std::move(from);
  }

  inline PopUp& operator=(PopUp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PopUp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PopUp* internal_default_instance() {
    return reinterpret_cast<const PopUp*>(
               &_PopUp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PopUp* other);
  friend void swap(PopUp& a, PopUp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PopUp* New() const PROTOBUF_FINAL { return New(NULL); }

  PopUp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PopUp& from);
  void MergeFrom(const PopUp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PopUp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.img.PopUp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rpc::img::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsPopUpImpl();
};
// -------------------------------------------------------------------

class Restore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Restore) */ {
 public:
  Restore();
  virtual ~Restore();

  Restore(const Restore& from);

  inline Restore& operator=(const Restore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Restore(Restore&& from) noexcept
    : Restore() {
    *this = ::std::move(from);
  }

  inline Restore& operator=(Restore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Restore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Restore* internal_default_instance() {
    return reinterpret_cast<const Restore*>(
               &_Restore_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Restore* other);
  friend void swap(Restore& a, Restore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Restore* New() const PROTOBUF_FINAL { return New(NULL); }

  Restore* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Restore& from);
  void MergeFrom(const Restore& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Restore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.img.Restore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::rpc::img::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsRestoreImpl();
};
// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(FileInfo* other);
  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  FileInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:rpc.img.FileInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsFileInfoImpl();
};
// -------------------------------------------------------------------

class KeyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.KeyInfo) */ {
 public:
  KeyInfo();
  virtual ~KeyInfo();

  KeyInfo(const KeyInfo& from);

  inline KeyInfo& operator=(const KeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyInfo(KeyInfo&& from) noexcept
    : KeyInfo() {
    *this = ::std::move(from);
  }

  inline KeyInfo& operator=(KeyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyInfo* internal_default_instance() {
    return reinterpret_cast<const KeyInfo*>(
               &_KeyInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(KeyInfo* other);
  friend void swap(KeyInfo& a, KeyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyInfo& from);
  void MergeFrom(const KeyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:rpc.img.KeyInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsKeyInfoImpl();
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(Path&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Path* other);
  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const PROTOBUF_FINAL { return New(NULL); }

  Path* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:rpc.img.Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsPathImpl();
};
// -------------------------------------------------------------------

class Coord2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Coord2D) */ {
 public:
  Coord2D();
  virtual ~Coord2D();

  Coord2D(const Coord2D& from);

  inline Coord2D& operator=(const Coord2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coord2D(Coord2D&& from) noexcept
    : Coord2D() {
    *this = ::std::move(from);
  }

  inline Coord2D& operator=(Coord2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Coord2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coord2D* internal_default_instance() {
    return reinterpret_cast<const Coord2D*>(
               &_Coord2D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Coord2D* other);
  friend void swap(Coord2D& a, Coord2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coord2D* New() const PROTOBUF_FINAL { return New(NULL); }

  Coord2D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Coord2D& from);
  void MergeFrom(const Coord2D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Coord2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:rpc.img.Coord2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsCoord2DImpl();
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const PROTOBUF_FINAL { return New(NULL); }

  Output* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device = 2;
  void clear_device();
  static const int kDeviceFieldNumber = 2;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // string devicetype = 3;
  void clear_devicetype();
  static const int kDevicetypeFieldNumber = 3;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // string orientation = 4;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::std::string& orientation() const;
  void set_orientation(const ::std::string& value);
  #if LANG_CXX11
  void set_orientation(::std::string&& value);
  #endif
  void set_orientation(const char* value);
  void set_orientation(const char* value, size_t size);
  ::std::string* mutable_orientation();
  ::std::string* release_orientation();
  void set_allocated_orientation(::std::string* orientation);

  // string media = 5;
  void clear_media();
  static const int kMediaFieldNumber = 5;
  const ::std::string& media() const;
  void set_media(const ::std::string& value);
  #if LANG_CXX11
  void set_media(::std::string&& value);
  #endif
  void set_media(const char* value);
  void set_media(const char* value, size_t size);
  ::std::string* mutable_media();
  ::std::string* release_media();
  void set_allocated_media(::std::string* media);

  // string format = 6;
  void clear_format();
  static const int kFormatFieldNumber = 6;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // float scale = 7;
  void clear_scale();
  static const int kScaleFieldNumber = 7;
  float scale() const;
  void set_scale(float value);

  // int32 dpi = 8;
  void clear_dpi();
  static const int kDpiFieldNumber = 8;
  ::google::protobuf::int32 dpi() const;
  void set_dpi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.img.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::google::protobuf::internal::ArenaStringPtr orientation_;
  ::google::protobuf::internal::ArenaStringPtr media_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::rpc::img::Id* panel_;
  float scale_;
  ::google::protobuf::int32 dpi_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsOutputImpl();
};
// -------------------------------------------------------------------

class SetChannel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.SetChannel) */ {
 public:
  SetChannel();
  virtual ~SetChannel();

  SetChannel(const SetChannel& from);

  inline SetChannel& operator=(const SetChannel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetChannel(SetChannel&& from) noexcept
    : SetChannel() {
    *this = ::std::move(from);
  }

  inline SetChannel& operator=(SetChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetChannel* internal_default_instance() {
    return reinterpret_cast<const SetChannel*>(
               &_SetChannel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SetChannel* other);
  friend void swap(SetChannel& a, SetChannel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetChannel* New() const PROTOBUF_FINAL { return New(NULL); }

  SetChannel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetChannel& from);
  void MergeFrom(const SetChannel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetChannel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // int32 number = 2;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.img.SetChannel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::img::Id* panel_;
  ::google::protobuf::int32 number_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsSetChannelImpl();
};
// -------------------------------------------------------------------

class SetZoomLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.SetZoomLevel) */ {
 public:
  SetZoomLevel();
  virtual ~SetZoomLevel();

  SetZoomLevel(const SetZoomLevel& from);

  inline SetZoomLevel& operator=(const SetZoomLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetZoomLevel(SetZoomLevel&& from) noexcept
    : SetZoomLevel() {
    *this = ::std::move(from);
  }

  inline SetZoomLevel& operator=(SetZoomLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetZoomLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetZoomLevel* internal_default_instance() {
    return reinterpret_cast<const SetZoomLevel*>(
               &_SetZoomLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SetZoomLevel* other);
  friend void swap(SetZoomLevel& a, SetZoomLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetZoomLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  SetZoomLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetZoomLevel& from);
  void MergeFrom(const SetZoomLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetZoomLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // int32 level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.img.SetZoomLevel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::img::Id* panel_;
  ::google::protobuf::int32 level_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsSetZoomLevelImpl();
};
// -------------------------------------------------------------------

class SetZoomBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.SetZoomBox) */ {
 public:
  SetZoomBox();
  virtual ~SetZoomBox();

  SetZoomBox(const SetZoomBox& from);

  inline SetZoomBox& operator=(const SetZoomBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetZoomBox(SetZoomBox&& from) noexcept
    : SetZoomBox() {
    *this = ::std::move(from);
  }

  inline SetZoomBox& operator=(SetZoomBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetZoomBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetZoomBox* internal_default_instance() {
    return reinterpret_cast<const SetZoomBox*>(
               &_SetZoomBox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SetZoomBox* other);
  friend void swap(SetZoomBox& a, SetZoomBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetZoomBox* New() const PROTOBUF_FINAL { return New(NULL); }

  SetZoomBox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetZoomBox& from);
  void MergeFrom(const SetZoomBox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetZoomBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string coord_type = 4;
  void clear_coord_type();
  static const int kCoordTypeFieldNumber = 4;
  const ::std::string& coord_type() const;
  void set_coord_type(const ::std::string& value);
  #if LANG_CXX11
  void set_coord_type(::std::string&& value);
  #endif
  void set_coord_type(const char* value);
  void set_coord_type(const char* value, size_t size);
  ::std::string* mutable_coord_type();
  ::std::string* release_coord_type();
  void set_allocated_coord_type(::std::string* coord_type);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // .rpc.img.Coord2D blc = 2;
  bool has_blc() const;
  void clear_blc();
  static const int kBlcFieldNumber = 2;
  const ::rpc::img::Coord2D& blc() const;
  ::rpc::img::Coord2D* release_blc();
  ::rpc::img::Coord2D* mutable_blc();
  void set_allocated_blc(::rpc::img::Coord2D* blc);

  // .rpc.img.Coord2D trc = 3;
  bool has_trc() const;
  void clear_trc();
  static const int kTrcFieldNumber = 3;
  const ::rpc::img::Coord2D& trc() const;
  ::rpc::img::Coord2D* release_trc();
  ::rpc::img::Coord2D* mutable_trc();
  void set_allocated_trc(::rpc::img::Coord2D* trc);

  // @@protoc_insertion_point(class_scope:rpc.img.SetZoomBox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr coord_type_;
  ::rpc::img::Id* panel_;
  ::rpc::img::Coord2D* blc_;
  ::rpc::img::Coord2D* trc_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsSetZoomBoxImpl();
};
// -------------------------------------------------------------------

class DataRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.DataRange) */ {
 public:
  DataRange();
  virtual ~DataRange();

  DataRange(const DataRange& from);

  inline DataRange& operator=(const DataRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataRange(DataRange&& from) noexcept
    : DataRange() {
    *this = ::std::move(from);
  }

  inline DataRange& operator=(DataRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataRange* internal_default_instance() {
    return reinterpret_cast<const DataRange*>(
               &_DataRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DataRange* other);
  friend void swap(DataRange& a, DataRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataRange* New() const PROTOBUF_FINAL { return New(NULL); }

  DataRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataRange& from);
  void MergeFrom(const DataRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.img.Id data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::rpc::img::Id& data() const;
  ::rpc::img::Id* release_data();
  ::rpc::img::Id* mutable_data();
  void set_allocated_data(::rpc::img::Id* data);

  // float min = 2;
  void clear_min();
  static const int kMinFieldNumber = 2;
  float min() const;
  void set_min(float value);

  // float max = 3;
  void clear_max();
  static const int kMaxFieldNumber = 3;
  float max() const;
  void set_max(float value);

  // @@protoc_insertion_point(class_scope:rpc.img.DataRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::img::Id* data_;
  float min_;
  float max_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsDataRangeImpl();
};
// -------------------------------------------------------------------

class ContourLevels : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.ContourLevels) */ {
 public:
  ContourLevels();
  virtual ~ContourLevels();

  ContourLevels(const ContourLevels& from);

  inline ContourLevels& operator=(const ContourLevels& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContourLevels(ContourLevels&& from) noexcept
    : ContourLevels() {
    *this = ::std::move(from);
  }

  inline ContourLevels& operator=(ContourLevels&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContourLevels& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContourLevels* internal_default_instance() {
    return reinterpret_cast<const ContourLevels*>(
               &_ContourLevels_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ContourLevels* other);
  friend void swap(ContourLevels& a, ContourLevels& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContourLevels* New() const PROTOBUF_FINAL { return New(NULL); }

  ContourLevels* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContourLevels& from);
  void MergeFrom(const ContourLevels& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContourLevels* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float levels = 2;
  int levels_size() const;
  void clear_levels();
  static const int kLevelsFieldNumber = 2;
  float levels(int index) const;
  void set_levels(int index, float value);
  void add_levels(float value);
  const ::google::protobuf::RepeatedField< float >&
      levels() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_levels();

  // .rpc.img.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::rpc::img::Id& id() const;
  ::rpc::img::Id* release_id();
  ::rpc::img::Id* mutable_id();
  void set_allocated_id(::rpc::img::Id* id);

  // float baselevel = 3;
  void clear_baselevel();
  static const int kBaselevelFieldNumber = 3;
  float baselevel() const;
  void set_baselevel(float value);

  // float unitlevel = 4;
  void clear_unitlevel();
  static const int kUnitlevelFieldNumber = 4;
  float unitlevel() const;
  void set_unitlevel(float value);

  // @@protoc_insertion_point(class_scope:rpc.img.ContourLevels)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > levels_;
  mutable int _levels_cached_byte_size_;
  ::rpc::img::Id* id_;
  float baselevel_;
  float unitlevel_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsContourLevelsImpl();
};
// -------------------------------------------------------------------

class ContourThickness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.ContourThickness) */ {
 public:
  ContourThickness();
  virtual ~ContourThickness();

  ContourThickness(const ContourThickness& from);

  inline ContourThickness& operator=(const ContourThickness& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContourThickness(ContourThickness&& from) noexcept
    : ContourThickness() {
    *this = ::std::move(from);
  }

  inline ContourThickness& operator=(ContourThickness&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContourThickness& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContourThickness* internal_default_instance() {
    return reinterpret_cast<const ContourThickness*>(
               &_ContourThickness_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ContourThickness* other);
  friend void swap(ContourThickness& a, ContourThickness& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContourThickness* New() const PROTOBUF_FINAL { return New(NULL); }

  ContourThickness* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContourThickness& from);
  void MergeFrom(const ContourThickness& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContourThickness* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.img.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::rpc::img::Id& id() const;
  ::rpc::img::Id* release_id();
  ::rpc::img::Id* mutable_id();
  void set_allocated_id(::rpc::img::Id* id);

  // float thickness = 2;
  void clear_thickness();
  static const int kThicknessFieldNumber = 2;
  float thickness() const;
  void set_thickness(float value);

  // @@protoc_insertion_point(class_scope:rpc.img.ContourThickness)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::img::Id* id_;
  float thickness_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsContourThicknessImpl();
};
// -------------------------------------------------------------------

class ContourColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.ContourColor) */ {
 public:
  ContourColor();
  virtual ~ContourColor();

  ContourColor(const ContourColor& from);

  inline ContourColor& operator=(const ContourColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContourColor(ContourColor&& from) noexcept
    : ContourColor() {
    *this = ::std::move(from);
  }

  inline ContourColor& operator=(ContourColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContourColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContourColor* internal_default_instance() {
    return reinterpret_cast<const ContourColor*>(
               &_ContourColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ContourColor* other);
  friend void swap(ContourColor& a, ContourColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContourColor* New() const PROTOBUF_FINAL { return New(NULL); }

  ContourColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContourColor& from);
  void MergeFrom(const ContourColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContourColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string color = 2;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  #if LANG_CXX11
  void set_color(::std::string&& value);
  #endif
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // .rpc.img.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::rpc::img::Id& id() const;
  ::rpc::img::Id* release_id();
  ::rpc::img::Id* mutable_id();
  void set_allocated_id(::rpc::img::Id* id);

  // @@protoc_insertion_point(class_scope:rpc.img.ContourColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::rpc::img::Id* id_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsContourColorImpl();
};
// -------------------------------------------------------------------

class Axes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Axes) */ {
 public:
  Axes();
  virtual ~Axes();

  Axes(const Axes& from);

  inline Axes& operator=(const Axes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Axes(Axes&& from) noexcept
    : Axes() {
    *this = ::std::move(from);
  }

  inline Axes& operator=(Axes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Axes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Axes* internal_default_instance() {
    return reinterpret_cast<const Axes*>(
               &_Axes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Axes* other);
  friend void swap(Axes& a, Axes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Axes* New() const PROTOBUF_FINAL { return New(NULL); }

  Axes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Axes& from);
  void MergeFrom(const Axes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Axes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const char* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // string y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const char* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // string z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  const ::std::string& z() const;
  void set_z(const ::std::string& value);
  #if LANG_CXX11
  void set_z(::std::string&& value);
  #endif
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  ::std::string* mutable_z();
  ::std::string* release_z();
  void set_allocated_z(::std::string* z);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // @@protoc_insertion_point(class_scope:rpc.img.Axes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  ::google::protobuf::internal::ArenaStringPtr z_;
  ::rpc::img::Id* panel_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsAxesImpl();
};
// -------------------------------------------------------------------

class ColorMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.ColorMap) */ {
 public:
  ColorMap();
  virtual ~ColorMap();

  ColorMap(const ColorMap& from);

  inline ColorMap& operator=(const ColorMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColorMap(ColorMap&& from) noexcept
    : ColorMap() {
    *this = ::std::move(from);
  }

  inline ColorMap& operator=(ColorMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColorMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColorMap* internal_default_instance() {
    return reinterpret_cast<const ColorMap*>(
               &_ColorMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ColorMap* other);
  friend void swap(ColorMap& a, ColorMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColorMap* New() const PROTOBUF_FINAL { return New(NULL); }

  ColorMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColorMap& from);
  void MergeFrom(const ColorMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColorMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string map = 2;
  void clear_map();
  static const int kMapFieldNumber = 2;
  const ::std::string& map() const;
  void set_map(const ::std::string& value);
  #if LANG_CXX11
  void set_map(::std::string&& value);
  #endif
  void set_map(const char* value);
  void set_map(const char* value, size_t size);
  ::std::string* mutable_map();
  ::std::string* release_map();
  void set_allocated_map(::std::string* map);

  // .rpc.img.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::rpc::img::Id& id() const;
  ::rpc::img::Id* release_id();
  ::rpc::img::Id* mutable_id();
  void set_allocated_id(::rpc::img::Id* id);

  // @@protoc_insertion_point(class_scope:rpc.img.ColorMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_;
  ::rpc::img::Id* id_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsColorMapImpl();
};
// -------------------------------------------------------------------

class Toggle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.Toggle) */ {
 public:
  Toggle();
  virtual ~Toggle();

  Toggle(const Toggle& from);

  inline Toggle& operator=(const Toggle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Toggle(Toggle&& from) noexcept
    : Toggle() {
    *this = ::std::move(from);
  }

  inline Toggle& operator=(Toggle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Toggle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Toggle* internal_default_instance() {
    return reinterpret_cast<const Toggle*>(
               &_Toggle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Toggle* other);
  friend void swap(Toggle& a, Toggle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Toggle* New() const PROTOBUF_FINAL { return New(NULL); }

  Toggle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Toggle& from);
  void MergeFrom(const Toggle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Toggle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rpc.img.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::rpc::img::Id& id() const;
  ::rpc::img::Id* release_id();
  ::rpc::img::Id* mutable_id();
  void set_allocated_id(::rpc::img::Id* id);

  // bool state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:rpc.img.Toggle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rpc::img::Id* id_;
  bool state_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsToggleImpl();
};
// -------------------------------------------------------------------

class InteractiveMaskOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.InteractiveMaskOptions) */ {
 public:
  InteractiveMaskOptions();
  virtual ~InteractiveMaskOptions();

  InteractiveMaskOptions(const InteractiveMaskOptions& from);

  inline InteractiveMaskOptions& operator=(const InteractiveMaskOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InteractiveMaskOptions(InteractiveMaskOptions&& from) noexcept
    : InteractiveMaskOptions() {
    *this = ::std::move(from);
  }

  inline InteractiveMaskOptions& operator=(InteractiveMaskOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InteractiveMaskOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InteractiveMaskOptions* internal_default_instance() {
    return reinterpret_cast<const InteractiveMaskOptions*>(
               &_InteractiveMaskOptions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(InteractiveMaskOptions* other);
  friend void swap(InteractiveMaskOptions& a, InteractiveMaskOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InteractiveMaskOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  InteractiveMaskOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InteractiveMaskOptions& from);
  void MergeFrom(const InteractiveMaskOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InteractiveMaskOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string threshold = 4;
  void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  const ::std::string& threshold() const;
  void set_threshold(const ::std::string& value);
  #if LANG_CXX11
  void set_threshold(::std::string&& value);
  #endif
  void set_threshold(const char* value);
  void set_threshold(const char* value, size_t size);
  ::std::string* mutable_threshold();
  ::std::string* release_threshold();
  void set_allocated_threshold(::std::string* threshold);

  // string cyclethreshold = 5;
  void clear_cyclethreshold();
  static const int kCyclethresholdFieldNumber = 5;
  const ::std::string& cyclethreshold() const;
  void set_cyclethreshold(const ::std::string& value);
  #if LANG_CXX11
  void set_cyclethreshold(::std::string&& value);
  #endif
  void set_cyclethreshold(const char* value);
  void set_cyclethreshold(const char* value, size_t size);
  ::std::string* mutable_cyclethreshold();
  ::std::string* release_cyclethreshold();
  void set_allocated_cyclethreshold(::std::string* cyclethreshold);

  // .rpc.img.Id panel = 1;
  bool has_panel() const;
  void clear_panel();
  static const int kPanelFieldNumber = 1;
  const ::rpc::img::Id& panel() const;
  ::rpc::img::Id* release_panel();
  ::rpc::img::Id* mutable_panel();
  void set_allocated_panel(::rpc::img::Id* panel);

  // int32 niter = 2;
  void clear_niter();
  static const int kNiterFieldNumber = 2;
  ::google::protobuf::int32 niter() const;
  void set_niter(::google::protobuf::int32 value);

  // int32 cycleniter = 3;
  void clear_cycleniter();
  static const int kCycleniterFieldNumber = 3;
  ::google::protobuf::int32 cycleniter() const;
  void set_cycleniter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.img.InteractiveMaskOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr threshold_;
  ::google::protobuf::internal::ArenaStringPtr cyclethreshold_;
  ::rpc::img::Id* panel_;
  ::google::protobuf::int32 niter_;
  ::google::protobuf::int32 cycleniter_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsInteractiveMaskOptionsImpl();
};
// -------------------------------------------------------------------

class InteractiveMaskResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.img.InteractiveMaskResult) */ {
 public:
  InteractiveMaskResult();
  virtual ~InteractiveMaskResult();

  InteractiveMaskResult(const InteractiveMaskResult& from);

  inline InteractiveMaskResult& operator=(const InteractiveMaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InteractiveMaskResult(InteractiveMaskResult&& from) noexcept
    : InteractiveMaskResult() {
    *this = ::std::move(from);
  }

  inline InteractiveMaskResult& operator=(InteractiveMaskResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InteractiveMaskResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InteractiveMaskResult* internal_default_instance() {
    return reinterpret_cast<const InteractiveMaskResult*>(
               &_InteractiveMaskResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(InteractiveMaskResult* other);
  friend void swap(InteractiveMaskResult& a, InteractiveMaskResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InteractiveMaskResult* New() const PROTOBUF_FINAL { return New(NULL); }

  InteractiveMaskResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InteractiveMaskResult& from);
  void MergeFrom(const InteractiveMaskResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InteractiveMaskResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // .rpc.img.InteractiveMaskOptions state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::rpc::img::InteractiveMaskOptions& state() const;
  ::rpc::img::InteractiveMaskOptions* release_state();
  ::rpc::img::InteractiveMaskOptions* mutable_state();
  void set_allocated_state(::rpc::img::InteractiveMaskOptions* state);

  // @@protoc_insertion_point(class_scope:rpc.img.InteractiveMaskResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::rpc::img::InteractiveMaskOptions* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_img_2eproto::TableStruct;
  friend void ::protobuf_img_2eproto::InitDefaultsInteractiveMaskResultImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Id

// int32 id = 1;
inline void Id::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Id::id() const {
  // @@protoc_insertion_point(field_get:rpc.img.Id.id)
  return id_;
}
inline void Id::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Id.id)
}

// -------------------------------------------------------------------

// NewPanel

// string type = 1;
inline void NewPanel::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPanel::type() const {
  // @@protoc_insertion_point(field_get:rpc.img.NewPanel.type)
  return type_.GetNoArena();
}
inline void NewPanel::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.NewPanel.type)
}
#if LANG_CXX11
inline void NewPanel::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.NewPanel.type)
}
#endif
inline void NewPanel::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.NewPanel.type)
}
inline void NewPanel::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.NewPanel.type)
}
inline ::std::string* NewPanel::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.NewPanel.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPanel::release_type() {
  // @@protoc_insertion_point(field_release:rpc.img.NewPanel.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPanel::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.NewPanel.type)
}

// bool hidden = 2;
inline void NewPanel::clear_hidden() {
  hidden_ = false;
}
inline bool NewPanel::hidden() const {
  // @@protoc_insertion_point(field_get:rpc.img.NewPanel.hidden)
  return hidden_;
}
inline void NewPanel::set_hidden(bool value) {
  
  hidden_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.NewPanel.hidden)
}

// -------------------------------------------------------------------

// NewData

// .rpc.img.Id panel = 1;
inline bool NewData::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void NewData::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& NewData::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.NewData.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* NewData::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.NewData.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* NewData::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.NewData.panel)
  return panel_;
}
inline void NewData::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.NewData.panel)
}

// string path = 2;
inline void NewData::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewData::path() const {
  // @@protoc_insertion_point(field_get:rpc.img.NewData.path)
  return path_.GetNoArena();
}
inline void NewData::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.NewData.path)
}
#if LANG_CXX11
inline void NewData::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.NewData.path)
}
#endif
inline void NewData::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.NewData.path)
}
inline void NewData::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.NewData.path)
}
inline ::std::string* NewData::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.NewData.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewData::release_path() {
  // @@protoc_insertion_point(field_release:rpc.img.NewData.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewData::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.NewData.path)
}

// string type = 3;
inline void NewData::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewData::type() const {
  // @@protoc_insertion_point(field_get:rpc.img.NewData.type)
  return type_.GetNoArena();
}
inline void NewData::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.NewData.type)
}
#if LANG_CXX11
inline void NewData::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.NewData.type)
}
#endif
inline void NewData::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.NewData.type)
}
inline void NewData::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.NewData.type)
}
inline ::std::string* NewData::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.NewData.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewData::release_type() {
  // @@protoc_insertion_point(field_release:rpc.img.NewData.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewData::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.NewData.type)
}

// float scale = 4;
inline void NewData::clear_scale() {
  scale_ = 0;
}
inline float NewData::scale() const {
  // @@protoc_insertion_point(field_get:rpc.img.NewData.scale)
  return scale_;
}
inline void NewData::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.NewData.scale)
}

// -------------------------------------------------------------------

// PopUp

// .rpc.img.Id panel = 1;
inline bool PopUp::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void PopUp::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& PopUp::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.PopUp.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* PopUp::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.PopUp.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* PopUp::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.PopUp.panel)
  return panel_;
}
inline void PopUp::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.PopUp.panel)
}

// string name = 2;
inline void PopUp::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PopUp::name() const {
  // @@protoc_insertion_point(field_get:rpc.img.PopUp.name)
  return name_.GetNoArena();
}
inline void PopUp::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.PopUp.name)
}
#if LANG_CXX11
inline void PopUp::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.PopUp.name)
}
#endif
inline void PopUp::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.PopUp.name)
}
inline void PopUp::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.PopUp.name)
}
inline ::std::string* PopUp::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.PopUp.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PopUp::release_name() {
  // @@protoc_insertion_point(field_release:rpc.img.PopUp.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PopUp::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.PopUp.name)
}

// -------------------------------------------------------------------

// Restore

// .rpc.img.Id panel = 1;
inline bool Restore::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void Restore::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& Restore::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.Restore.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* Restore::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.Restore.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* Restore::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.Restore.panel)
  return panel_;
}
inline void Restore::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Restore.panel)
}

// string path = 2;
inline void Restore::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Restore::path() const {
  // @@protoc_insertion_point(field_get:rpc.img.Restore.path)
  return path_.GetNoArena();
}
inline void Restore::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Restore.path)
}
#if LANG_CXX11
inline void Restore::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Restore.path)
}
#endif
inline void Restore::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Restore.path)
}
inline void Restore::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Restore.path)
}
inline ::std::string* Restore::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Restore.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Restore::release_path() {
  // @@protoc_insertion_point(field_release:rpc.img.Restore.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Restore::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Restore.path)
}

// -------------------------------------------------------------------

// FileInfo

// string type = 1;
inline void FileInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::type() const {
  // @@protoc_insertion_point(field_get:rpc.img.FileInfo.type)
  return type_.GetNoArena();
}
inline void FileInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.FileInfo.type)
}
#if LANG_CXX11
inline void FileInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.FileInfo.type)
}
#endif
inline void FileInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.FileInfo.type)
}
inline void FileInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.FileInfo.type)
}
inline ::std::string* FileInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.FileInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_type() {
  // @@protoc_insertion_point(field_release:rpc.img.FileInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.FileInfo.type)
}

// -------------------------------------------------------------------

// KeyInfo

// string type = 1;
inline void KeyInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::type() const {
  // @@protoc_insertion_point(field_get:rpc.img.KeyInfo.type)
  return type_.GetNoArena();
}
inline void KeyInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.KeyInfo.type)
}
#if LANG_CXX11
inline void KeyInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.KeyInfo.type)
}
#endif
inline void KeyInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.KeyInfo.type)
}
inline void KeyInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.KeyInfo.type)
}
inline ::std::string* KeyInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.KeyInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_type() {
  // @@protoc_insertion_point(field_release:rpc.img.KeyInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.KeyInfo.type)
}

// -------------------------------------------------------------------

// Path

// string path = 1;
inline void Path::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Path::path() const {
  // @@protoc_insertion_point(field_get:rpc.img.Path.path)
  return path_.GetNoArena();
}
inline void Path::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Path.path)
}
#if LANG_CXX11
inline void Path::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Path.path)
}
#endif
inline void Path::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Path.path)
}
inline void Path::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Path.path)
}
inline ::std::string* Path::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Path.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Path::release_path() {
  // @@protoc_insertion_point(field_release:rpc.img.Path.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Path.path)
}

// -------------------------------------------------------------------

// Coord2D

// float x = 1;
inline void Coord2D::clear_x() {
  x_ = 0;
}
inline float Coord2D::x() const {
  // @@protoc_insertion_point(field_get:rpc.img.Coord2D.x)
  return x_;
}
inline void Coord2D::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Coord2D.x)
}

// float y = 2;
inline void Coord2D::clear_y() {
  y_ = 0;
}
inline float Coord2D::y() const {
  // @@protoc_insertion_point(field_get:rpc.img.Coord2D.y)
  return y_;
}
inline void Coord2D::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Coord2D.y)
}

// -------------------------------------------------------------------

// Output

// .rpc.img.Id panel = 1;
inline bool Output::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void Output::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& Output::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.Output.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* Output::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* Output::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.panel)
  return panel_;
}
inline void Output::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.panel)
}

// string device = 2;
inline void Output::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::device() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.device)
  return device_.GetNoArena();
}
inline void Output::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Output.device)
}
#if LANG_CXX11
inline void Output::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Output.device)
}
#endif
inline void Output::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Output.device)
}
inline void Output::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Output.device)
}
inline ::std::string* Output::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_device() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.device)
}

// string devicetype = 3;
inline void Output::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::devicetype() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.devicetype)
  return devicetype_.GetNoArena();
}
inline void Output::set_devicetype(const ::std::string& value) {
  
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Output.devicetype)
}
#if LANG_CXX11
inline void Output::set_devicetype(::std::string&& value) {
  
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Output.devicetype)
}
#endif
inline void Output::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Output.devicetype)
}
inline void Output::set_devicetype(const char* value, size_t size) {
  
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Output.devicetype)
}
inline ::std::string* Output::mutable_devicetype() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.devicetype)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_devicetype() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.devicetype)
  
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    
  } else {
    
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.devicetype)
}

// string orientation = 4;
inline void Output::clear_orientation() {
  orientation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::orientation() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.orientation)
  return orientation_.GetNoArena();
}
inline void Output::set_orientation(const ::std::string& value) {
  
  orientation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Output.orientation)
}
#if LANG_CXX11
inline void Output::set_orientation(::std::string&& value) {
  
  orientation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Output.orientation)
}
#endif
inline void Output::set_orientation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  orientation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Output.orientation)
}
inline void Output::set_orientation(const char* value, size_t size) {
  
  orientation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Output.orientation)
}
inline ::std::string* Output::mutable_orientation() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.orientation)
  return orientation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_orientation() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.orientation)
  
  return orientation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_orientation(::std::string* orientation) {
  if (orientation != NULL) {
    
  } else {
    
  }
  orientation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orientation);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.orientation)
}

// string media = 5;
inline void Output::clear_media() {
  media_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::media() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.media)
  return media_.GetNoArena();
}
inline void Output::set_media(const ::std::string& value) {
  
  media_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Output.media)
}
#if LANG_CXX11
inline void Output::set_media(::std::string&& value) {
  
  media_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Output.media)
}
#endif
inline void Output::set_media(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  media_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Output.media)
}
inline void Output::set_media(const char* value, size_t size) {
  
  media_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Output.media)
}
inline ::std::string* Output::mutable_media() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.media)
  return media_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_media() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.media)
  
  return media_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_media(::std::string* media) {
  if (media != NULL) {
    
  } else {
    
  }
  media_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), media);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.media)
}

// string format = 6;
inline void Output::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::format() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.format)
  return format_.GetNoArena();
}
inline void Output::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Output.format)
}
#if LANG_CXX11
inline void Output::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Output.format)
}
#endif
inline void Output::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Output.format)
}
inline void Output::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Output.format)
}
inline ::std::string* Output::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Output.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_format() {
  // @@protoc_insertion_point(field_release:rpc.img.Output.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Output.format)
}

// float scale = 7;
inline void Output::clear_scale() {
  scale_ = 0;
}
inline float Output::scale() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.scale)
  return scale_;
}
inline void Output::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Output.scale)
}

// int32 dpi = 8;
inline void Output::clear_dpi() {
  dpi_ = 0;
}
inline ::google::protobuf::int32 Output::dpi() const {
  // @@protoc_insertion_point(field_get:rpc.img.Output.dpi)
  return dpi_;
}
inline void Output::set_dpi(::google::protobuf::int32 value) {
  
  dpi_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Output.dpi)
}

// -------------------------------------------------------------------

// SetChannel

// .rpc.img.Id panel = 1;
inline bool SetChannel::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void SetChannel::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& SetChannel::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.SetChannel.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* SetChannel::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.SetChannel.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* SetChannel::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.SetChannel.panel)
  return panel_;
}
inline void SetChannel::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetChannel.panel)
}

// int32 number = 2;
inline void SetChannel::clear_number() {
  number_ = 0;
}
inline ::google::protobuf::int32 SetChannel::number() const {
  // @@protoc_insertion_point(field_get:rpc.img.SetChannel.number)
  return number_;
}
inline void SetChannel::set_number(::google::protobuf::int32 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.SetChannel.number)
}

// -------------------------------------------------------------------

// SetZoomLevel

// .rpc.img.Id panel = 1;
inline bool SetZoomLevel::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void SetZoomLevel::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& SetZoomLevel::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomLevel.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* SetZoomLevel::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.SetZoomLevel.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* SetZoomLevel::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.SetZoomLevel.panel)
  return panel_;
}
inline void SetZoomLevel::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetZoomLevel.panel)
}

// int32 level = 2;
inline void SetZoomLevel::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 SetZoomLevel::level() const {
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomLevel.level)
  return level_;
}
inline void SetZoomLevel::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.SetZoomLevel.level)
}

// -------------------------------------------------------------------

// SetZoomBox

// .rpc.img.Id panel = 1;
inline bool SetZoomBox::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void SetZoomBox::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& SetZoomBox::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomBox.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* SetZoomBox::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.SetZoomBox.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* SetZoomBox::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.SetZoomBox.panel)
  return panel_;
}
inline void SetZoomBox::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetZoomBox.panel)
}

// .rpc.img.Coord2D blc = 2;
inline bool SetZoomBox::has_blc() const {
  return this != internal_default_instance() && blc_ != NULL;
}
inline void SetZoomBox::clear_blc() {
  if (GetArenaNoVirtual() == NULL && blc_ != NULL) {
    delete blc_;
  }
  blc_ = NULL;
}
inline const ::rpc::img::Coord2D& SetZoomBox::blc() const {
  const ::rpc::img::Coord2D* p = blc_;
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomBox.blc)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Coord2D*>(
      &::rpc::img::_Coord2D_default_instance_);
}
inline ::rpc::img::Coord2D* SetZoomBox::release_blc() {
  // @@protoc_insertion_point(field_release:rpc.img.SetZoomBox.blc)
  
  ::rpc::img::Coord2D* temp = blc_;
  blc_ = NULL;
  return temp;
}
inline ::rpc::img::Coord2D* SetZoomBox::mutable_blc() {
  
  if (blc_ == NULL) {
    blc_ = new ::rpc::img::Coord2D;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.SetZoomBox.blc)
  return blc_;
}
inline void SetZoomBox::set_allocated_blc(::rpc::img::Coord2D* blc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blc_;
  }
  if (blc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blc, submessage_arena);
    }
    
  } else {
    
  }
  blc_ = blc;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetZoomBox.blc)
}

// .rpc.img.Coord2D trc = 3;
inline bool SetZoomBox::has_trc() const {
  return this != internal_default_instance() && trc_ != NULL;
}
inline void SetZoomBox::clear_trc() {
  if (GetArenaNoVirtual() == NULL && trc_ != NULL) {
    delete trc_;
  }
  trc_ = NULL;
}
inline const ::rpc::img::Coord2D& SetZoomBox::trc() const {
  const ::rpc::img::Coord2D* p = trc_;
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomBox.trc)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Coord2D*>(
      &::rpc::img::_Coord2D_default_instance_);
}
inline ::rpc::img::Coord2D* SetZoomBox::release_trc() {
  // @@protoc_insertion_point(field_release:rpc.img.SetZoomBox.trc)
  
  ::rpc::img::Coord2D* temp = trc_;
  trc_ = NULL;
  return temp;
}
inline ::rpc::img::Coord2D* SetZoomBox::mutable_trc() {
  
  if (trc_ == NULL) {
    trc_ = new ::rpc::img::Coord2D;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.SetZoomBox.trc)
  return trc_;
}
inline void SetZoomBox::set_allocated_trc(::rpc::img::Coord2D* trc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trc_;
  }
  if (trc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trc, submessage_arena);
    }
    
  } else {
    
  }
  trc_ = trc;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetZoomBox.trc)
}

// string coord_type = 4;
inline void SetZoomBox::clear_coord_type() {
  coord_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetZoomBox::coord_type() const {
  // @@protoc_insertion_point(field_get:rpc.img.SetZoomBox.coord_type)
  return coord_type_.GetNoArena();
}
inline void SetZoomBox::set_coord_type(const ::std::string& value) {
  
  coord_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.SetZoomBox.coord_type)
}
#if LANG_CXX11
inline void SetZoomBox::set_coord_type(::std::string&& value) {
  
  coord_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.SetZoomBox.coord_type)
}
#endif
inline void SetZoomBox::set_coord_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  coord_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.SetZoomBox.coord_type)
}
inline void SetZoomBox::set_coord_type(const char* value, size_t size) {
  
  coord_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.SetZoomBox.coord_type)
}
inline ::std::string* SetZoomBox::mutable_coord_type() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.SetZoomBox.coord_type)
  return coord_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetZoomBox::release_coord_type() {
  // @@protoc_insertion_point(field_release:rpc.img.SetZoomBox.coord_type)
  
  return coord_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetZoomBox::set_allocated_coord_type(::std::string* coord_type) {
  if (coord_type != NULL) {
    
  } else {
    
  }
  coord_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coord_type);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.SetZoomBox.coord_type)
}

// -------------------------------------------------------------------

// DataRange

// .rpc.img.Id data = 1;
inline bool DataRange::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void DataRange::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::rpc::img::Id& DataRange::data() const {
  const ::rpc::img::Id* p = data_;
  // @@protoc_insertion_point(field_get:rpc.img.DataRange.data)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* DataRange::release_data() {
  // @@protoc_insertion_point(field_release:rpc.img.DataRange.data)
  
  ::rpc::img::Id* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::rpc::img::Id* DataRange::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.DataRange.data)
  return data_;
}
inline void DataRange::set_allocated_data(::rpc::img::Id* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.DataRange.data)
}

// float min = 2;
inline void DataRange::clear_min() {
  min_ = 0;
}
inline float DataRange::min() const {
  // @@protoc_insertion_point(field_get:rpc.img.DataRange.min)
  return min_;
}
inline void DataRange::set_min(float value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.DataRange.min)
}

// float max = 3;
inline void DataRange::clear_max() {
  max_ = 0;
}
inline float DataRange::max() const {
  // @@protoc_insertion_point(field_get:rpc.img.DataRange.max)
  return max_;
}
inline void DataRange::set_max(float value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.DataRange.max)
}

// -------------------------------------------------------------------

// ContourLevels

// .rpc.img.Id id = 1;
inline bool ContourLevels::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ContourLevels::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::rpc::img::Id& ContourLevels::id() const {
  const ::rpc::img::Id* p = id_;
  // @@protoc_insertion_point(field_get:rpc.img.ContourLevels.id)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* ContourLevels::release_id() {
  // @@protoc_insertion_point(field_release:rpc.img.ContourLevels.id)
  
  ::rpc::img::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::rpc::img::Id* ContourLevels::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.ContourLevels.id)
  return id_;
}
inline void ContourLevels::set_allocated_id(::rpc::img::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ContourLevels.id)
}

// repeated float levels = 2;
inline int ContourLevels::levels_size() const {
  return levels_.size();
}
inline void ContourLevels::clear_levels() {
  levels_.Clear();
}
inline float ContourLevels::levels(int index) const {
  // @@protoc_insertion_point(field_get:rpc.img.ContourLevels.levels)
  return levels_.Get(index);
}
inline void ContourLevels::set_levels(int index, float value) {
  levels_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpc.img.ContourLevels.levels)
}
inline void ContourLevels::add_levels(float value) {
  levels_.Add(value);
  // @@protoc_insertion_point(field_add:rpc.img.ContourLevels.levels)
}
inline const ::google::protobuf::RepeatedField< float >&
ContourLevels::levels() const {
  // @@protoc_insertion_point(field_list:rpc.img.ContourLevels.levels)
  return levels_;
}
inline ::google::protobuf::RepeatedField< float >*
ContourLevels::mutable_levels() {
  // @@protoc_insertion_point(field_mutable_list:rpc.img.ContourLevels.levels)
  return &levels_;
}

// float baselevel = 3;
inline void ContourLevels::clear_baselevel() {
  baselevel_ = 0;
}
inline float ContourLevels::baselevel() const {
  // @@protoc_insertion_point(field_get:rpc.img.ContourLevels.baselevel)
  return baselevel_;
}
inline void ContourLevels::set_baselevel(float value) {
  
  baselevel_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.ContourLevels.baselevel)
}

// float unitlevel = 4;
inline void ContourLevels::clear_unitlevel() {
  unitlevel_ = 0;
}
inline float ContourLevels::unitlevel() const {
  // @@protoc_insertion_point(field_get:rpc.img.ContourLevels.unitlevel)
  return unitlevel_;
}
inline void ContourLevels::set_unitlevel(float value) {
  
  unitlevel_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.ContourLevels.unitlevel)
}

// -------------------------------------------------------------------

// ContourThickness

// .rpc.img.Id id = 1;
inline bool ContourThickness::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ContourThickness::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::rpc::img::Id& ContourThickness::id() const {
  const ::rpc::img::Id* p = id_;
  // @@protoc_insertion_point(field_get:rpc.img.ContourThickness.id)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* ContourThickness::release_id() {
  // @@protoc_insertion_point(field_release:rpc.img.ContourThickness.id)
  
  ::rpc::img::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::rpc::img::Id* ContourThickness::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.ContourThickness.id)
  return id_;
}
inline void ContourThickness::set_allocated_id(::rpc::img::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ContourThickness.id)
}

// float thickness = 2;
inline void ContourThickness::clear_thickness() {
  thickness_ = 0;
}
inline float ContourThickness::thickness() const {
  // @@protoc_insertion_point(field_get:rpc.img.ContourThickness.thickness)
  return thickness_;
}
inline void ContourThickness::set_thickness(float value) {
  
  thickness_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.ContourThickness.thickness)
}

// -------------------------------------------------------------------

// ContourColor

// .rpc.img.Id id = 1;
inline bool ContourColor::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ContourColor::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::rpc::img::Id& ContourColor::id() const {
  const ::rpc::img::Id* p = id_;
  // @@protoc_insertion_point(field_get:rpc.img.ContourColor.id)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* ContourColor::release_id() {
  // @@protoc_insertion_point(field_release:rpc.img.ContourColor.id)
  
  ::rpc::img::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::rpc::img::Id* ContourColor::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.ContourColor.id)
  return id_;
}
inline void ContourColor::set_allocated_id(::rpc::img::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ContourColor.id)
}

// string color = 2;
inline void ContourColor::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContourColor::color() const {
  // @@protoc_insertion_point(field_get:rpc.img.ContourColor.color)
  return color_.GetNoArena();
}
inline void ContourColor::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.ContourColor.color)
}
#if LANG_CXX11
inline void ContourColor::set_color(::std::string&& value) {
  
  color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.ContourColor.color)
}
#endif
inline void ContourColor::set_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.ContourColor.color)
}
inline void ContourColor::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.ContourColor.color)
}
inline ::std::string* ContourColor::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.ContourColor.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContourColor::release_color() {
  // @@protoc_insertion_point(field_release:rpc.img.ContourColor.color)
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContourColor::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ContourColor.color)
}

// -------------------------------------------------------------------

// Axes

// .rpc.img.Id panel = 1;
inline bool Axes::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void Axes::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& Axes::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.Axes.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* Axes::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.Axes.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* Axes::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.Axes.panel)
  return panel_;
}
inline void Axes::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Axes.panel)
}

// string x = 2;
inline void Axes::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Axes::x() const {
  // @@protoc_insertion_point(field_get:rpc.img.Axes.x)
  return x_.GetNoArena();
}
inline void Axes::set_x(const ::std::string& value) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Axes.x)
}
#if LANG_CXX11
inline void Axes::set_x(::std::string&& value) {
  
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Axes.x)
}
#endif
inline void Axes::set_x(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Axes.x)
}
inline void Axes::set_x(const char* value, size_t size) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Axes.x)
}
inline ::std::string* Axes::mutable_x() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Axes.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Axes::release_x() {
  // @@protoc_insertion_point(field_release:rpc.img.Axes.x)
  
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Axes::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    
  } else {
    
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Axes.x)
}

// string y = 3;
inline void Axes::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Axes::y() const {
  // @@protoc_insertion_point(field_get:rpc.img.Axes.y)
  return y_.GetNoArena();
}
inline void Axes::set_y(const ::std::string& value) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Axes.y)
}
#if LANG_CXX11
inline void Axes::set_y(::std::string&& value) {
  
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Axes.y)
}
#endif
inline void Axes::set_y(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Axes.y)
}
inline void Axes::set_y(const char* value, size_t size) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Axes.y)
}
inline ::std::string* Axes::mutable_y() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Axes.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Axes::release_y() {
  // @@protoc_insertion_point(field_release:rpc.img.Axes.y)
  
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Axes::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    
  } else {
    
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Axes.y)
}

// string z = 4;
inline void Axes::clear_z() {
  z_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Axes::z() const {
  // @@protoc_insertion_point(field_get:rpc.img.Axes.z)
  return z_.GetNoArena();
}
inline void Axes::set_z(const ::std::string& value) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.Axes.z)
}
#if LANG_CXX11
inline void Axes::set_z(::std::string&& value) {
  
  z_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.Axes.z)
}
#endif
inline void Axes::set_z(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.Axes.z)
}
inline void Axes::set_z(const char* value, size_t size) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.Axes.z)
}
inline ::std::string* Axes::mutable_z() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.Axes.z)
  return z_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Axes::release_z() {
  // @@protoc_insertion_point(field_release:rpc.img.Axes.z)
  
  return z_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Axes::set_allocated_z(::std::string* z) {
  if (z != NULL) {
    
  } else {
    
  }
  z_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), z);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Axes.z)
}

// -------------------------------------------------------------------

// ColorMap

// .rpc.img.Id id = 1;
inline bool ColorMap::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ColorMap::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::rpc::img::Id& ColorMap::id() const {
  const ::rpc::img::Id* p = id_;
  // @@protoc_insertion_point(field_get:rpc.img.ColorMap.id)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* ColorMap::release_id() {
  // @@protoc_insertion_point(field_release:rpc.img.ColorMap.id)
  
  ::rpc::img::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::rpc::img::Id* ColorMap::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.ColorMap.id)
  return id_;
}
inline void ColorMap::set_allocated_id(::rpc::img::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ColorMap.id)
}

// string map = 2;
inline void ColorMap::clear_map() {
  map_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ColorMap::map() const {
  // @@protoc_insertion_point(field_get:rpc.img.ColorMap.map)
  return map_.GetNoArena();
}
inline void ColorMap::set_map(const ::std::string& value) {
  
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.ColorMap.map)
}
#if LANG_CXX11
inline void ColorMap::set_map(::std::string&& value) {
  
  map_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.ColorMap.map)
}
#endif
inline void ColorMap::set_map(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.ColorMap.map)
}
inline void ColorMap::set_map(const char* value, size_t size) {
  
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.ColorMap.map)
}
inline ::std::string* ColorMap::mutable_map() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.ColorMap.map)
  return map_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColorMap::release_map() {
  // @@protoc_insertion_point(field_release:rpc.img.ColorMap.map)
  
  return map_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColorMap::set_allocated_map(::std::string* map) {
  if (map != NULL) {
    
  } else {
    
  }
  map_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.ColorMap.map)
}

// -------------------------------------------------------------------

// Toggle

// .rpc.img.Id id = 1;
inline bool Toggle::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void Toggle::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::rpc::img::Id& Toggle::id() const {
  const ::rpc::img::Id* p = id_;
  // @@protoc_insertion_point(field_get:rpc.img.Toggle.id)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* Toggle::release_id() {
  // @@protoc_insertion_point(field_release:rpc.img.Toggle.id)
  
  ::rpc::img::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::rpc::img::Id* Toggle::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.Toggle.id)
  return id_;
}
inline void Toggle::set_allocated_id(::rpc::img::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.Toggle.id)
}

// bool state = 2;
inline void Toggle::clear_state() {
  state_ = false;
}
inline bool Toggle::state() const {
  // @@protoc_insertion_point(field_get:rpc.img.Toggle.state)
  return state_;
}
inline void Toggle::set_state(bool value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.Toggle.state)
}

// -------------------------------------------------------------------

// InteractiveMaskOptions

// .rpc.img.Id panel = 1;
inline bool InteractiveMaskOptions::has_panel() const {
  return this != internal_default_instance() && panel_ != NULL;
}
inline void InteractiveMaskOptions::clear_panel() {
  if (GetArenaNoVirtual() == NULL && panel_ != NULL) {
    delete panel_;
  }
  panel_ = NULL;
}
inline const ::rpc::img::Id& InteractiveMaskOptions::panel() const {
  const ::rpc::img::Id* p = panel_;
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskOptions.panel)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::Id*>(
      &::rpc::img::_Id_default_instance_);
}
inline ::rpc::img::Id* InteractiveMaskOptions::release_panel() {
  // @@protoc_insertion_point(field_release:rpc.img.InteractiveMaskOptions.panel)
  
  ::rpc::img::Id* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline ::rpc::img::Id* InteractiveMaskOptions::mutable_panel() {
  
  if (panel_ == NULL) {
    panel_ = new ::rpc::img::Id;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.InteractiveMaskOptions.panel)
  return panel_;
}
inline void InteractiveMaskOptions::set_allocated_panel(::rpc::img::Id* panel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete panel_;
  }
  if (panel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      panel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, panel, submessage_arena);
    }
    
  } else {
    
  }
  panel_ = panel;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.InteractiveMaskOptions.panel)
}

// int32 niter = 2;
inline void InteractiveMaskOptions::clear_niter() {
  niter_ = 0;
}
inline ::google::protobuf::int32 InteractiveMaskOptions::niter() const {
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskOptions.niter)
  return niter_;
}
inline void InteractiveMaskOptions::set_niter(::google::protobuf::int32 value) {
  
  niter_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.InteractiveMaskOptions.niter)
}

// int32 cycleniter = 3;
inline void InteractiveMaskOptions::clear_cycleniter() {
  cycleniter_ = 0;
}
inline ::google::protobuf::int32 InteractiveMaskOptions::cycleniter() const {
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskOptions.cycleniter)
  return cycleniter_;
}
inline void InteractiveMaskOptions::set_cycleniter(::google::protobuf::int32 value) {
  
  cycleniter_ = value;
  // @@protoc_insertion_point(field_set:rpc.img.InteractiveMaskOptions.cycleniter)
}

// string threshold = 4;
inline void InteractiveMaskOptions::clear_threshold() {
  threshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InteractiveMaskOptions::threshold() const {
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskOptions.threshold)
  return threshold_.GetNoArena();
}
inline void InteractiveMaskOptions::set_threshold(const ::std::string& value) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.InteractiveMaskOptions.threshold)
}
#if LANG_CXX11
inline void InteractiveMaskOptions::set_threshold(::std::string&& value) {
  
  threshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.InteractiveMaskOptions.threshold)
}
#endif
inline void InteractiveMaskOptions::set_threshold(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.InteractiveMaskOptions.threshold)
}
inline void InteractiveMaskOptions::set_threshold(const char* value, size_t size) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.InteractiveMaskOptions.threshold)
}
inline ::std::string* InteractiveMaskOptions::mutable_threshold() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.InteractiveMaskOptions.threshold)
  return threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InteractiveMaskOptions::release_threshold() {
  // @@protoc_insertion_point(field_release:rpc.img.InteractiveMaskOptions.threshold)
  
  return threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InteractiveMaskOptions::set_allocated_threshold(::std::string* threshold) {
  if (threshold != NULL) {
    
  } else {
    
  }
  threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), threshold);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.InteractiveMaskOptions.threshold)
}

// string cyclethreshold = 5;
inline void InteractiveMaskOptions::clear_cyclethreshold() {
  cyclethreshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InteractiveMaskOptions::cyclethreshold() const {
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskOptions.cyclethreshold)
  return cyclethreshold_.GetNoArena();
}
inline void InteractiveMaskOptions::set_cyclethreshold(const ::std::string& value) {
  
  cyclethreshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.InteractiveMaskOptions.cyclethreshold)
}
#if LANG_CXX11
inline void InteractiveMaskOptions::set_cyclethreshold(::std::string&& value) {
  
  cyclethreshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.InteractiveMaskOptions.cyclethreshold)
}
#endif
inline void InteractiveMaskOptions::set_cyclethreshold(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cyclethreshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.InteractiveMaskOptions.cyclethreshold)
}
inline void InteractiveMaskOptions::set_cyclethreshold(const char* value, size_t size) {
  
  cyclethreshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.InteractiveMaskOptions.cyclethreshold)
}
inline ::std::string* InteractiveMaskOptions::mutable_cyclethreshold() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.InteractiveMaskOptions.cyclethreshold)
  return cyclethreshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InteractiveMaskOptions::release_cyclethreshold() {
  // @@protoc_insertion_point(field_release:rpc.img.InteractiveMaskOptions.cyclethreshold)
  
  return cyclethreshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InteractiveMaskOptions::set_allocated_cyclethreshold(::std::string* cyclethreshold) {
  if (cyclethreshold != NULL) {
    
  } else {
    
  }
  cyclethreshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cyclethreshold);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.InteractiveMaskOptions.cyclethreshold)
}

// -------------------------------------------------------------------

// InteractiveMaskResult

// string action = 1;
inline void InteractiveMaskResult::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InteractiveMaskResult::action() const {
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskResult.action)
  return action_.GetNoArena();
}
inline void InteractiveMaskResult::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.img.InteractiveMaskResult.action)
}
#if LANG_CXX11
inline void InteractiveMaskResult::set_action(::std::string&& value) {
  
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.img.InteractiveMaskResult.action)
}
#endif
inline void InteractiveMaskResult::set_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.img.InteractiveMaskResult.action)
}
inline void InteractiveMaskResult::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.img.InteractiveMaskResult.action)
}
inline ::std::string* InteractiveMaskResult::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:rpc.img.InteractiveMaskResult.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InteractiveMaskResult::release_action() {
  // @@protoc_insertion_point(field_release:rpc.img.InteractiveMaskResult.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InteractiveMaskResult::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:rpc.img.InteractiveMaskResult.action)
}

// .rpc.img.InteractiveMaskOptions state = 2;
inline bool InteractiveMaskResult::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void InteractiveMaskResult::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::rpc::img::InteractiveMaskOptions& InteractiveMaskResult::state() const {
  const ::rpc::img::InteractiveMaskOptions* p = state_;
  // @@protoc_insertion_point(field_get:rpc.img.InteractiveMaskResult.state)
  return p != NULL ? *p : *reinterpret_cast<const ::rpc::img::InteractiveMaskOptions*>(
      &::rpc::img::_InteractiveMaskOptions_default_instance_);
}
inline ::rpc::img::InteractiveMaskOptions* InteractiveMaskResult::release_state() {
  // @@protoc_insertion_point(field_release:rpc.img.InteractiveMaskResult.state)
  
  ::rpc::img::InteractiveMaskOptions* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::rpc::img::InteractiveMaskOptions* InteractiveMaskResult::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::rpc::img::InteractiveMaskOptions;
  }
  // @@protoc_insertion_point(field_mutable:rpc.img.InteractiveMaskResult.state)
  return state_;
}
inline void InteractiveMaskResult::set_allocated_state(::rpc::img::InteractiveMaskOptions* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:rpc.img.InteractiveMaskResult.state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace img
}  // namespace rpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_img_2eproto__INCLUDED
