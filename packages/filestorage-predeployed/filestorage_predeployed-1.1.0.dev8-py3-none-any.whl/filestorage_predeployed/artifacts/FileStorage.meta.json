{
    "name": "FileStorage",
    "solcVersion": "0.8.9",
    "solcLongVersion": "0.8.9+commit.e5eed63a",
    "input": {
        "language": "Solidity",
        "sources": {
            "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n    uint256[49] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
            },
            "contracts/FileStorage.sol": {
                "content": "/*\n    FileStorage.sol - SKALE FileStorage\n    Copyright (C) 2018-Present SKALE Labs\n    @author Dmytro Nazarenko\n\n    FileStorage is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    FileStorage is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with FileStorage.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.8.9;\n\nimport \"./Utils.sol\";\nimport \"./PrecompiledCaller.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\";\n\n\ncontract FileStorage is AccessControlEnumerableUpgradeable {\n\n    bytes32 public constant ALLOCATOR_ROLE = keccak256(\"ALLOCATOR_ROLE\");\n    bytes32 public constant STORAGE_SPACE_SLOT = keccak256(\"STORAGE_SPACE_SLOT\");\n\n    uint public constant MEGABYTE = 2 ** 20;\n    uint public constant MAX_BLOCK_COUNT = 2 ** 15;\n    uint public constant EMPTY_INDEX = 0;\n\n    uint internal constant MAX_CONTENT_COUNT = 2 ** 13;\n\n    uint public constant MAX_FILESIZE = 100 * MEGABYTE;\n    uint internal constant MAX_CHUNK_SIZE = 1 * MEGABYTE;\n\n\n    enum FileStatus { NONEXISTENT, UPLOADING, COMPLETED }\n\n    struct ContentInfo {\n        string name;\n        bool isFile;\n        uint size;\n        FileStatus status;\n        bool[] isChunkUploaded;\n    }\n\n    struct DetailedInfo {\n        bool isImmutable;\n    }\n\n    struct Directory {\n        ContentInfo[] contents;\n        mapping(string => uint) contentIndexes;\n        mapping(string => Directory) directories;\n        mapping(string => DetailedInfo) contentDetails;\n    }\n\n    mapping(address => uint) reservedStorageSpace;\n    mapping(address => uint) occupiedStorageSpace;\n    mapping(address => Directory) rootDirectories;\n\n    uint totalReservedSpace = 0;\n    string public version;\n\n    function reserveSpace(address userAddress, uint reservedSpace) external {\n        require(hasRole(ALLOCATOR_ROLE, msg.sender), \"Caller is not allowed to reserve space\");\n        require(occupiedStorageSpace[userAddress] <= reservedSpace, \"Could not reserve less than used space\");\n        totalReservedSpace -= reservedStorageSpace[userAddress];\n        require(totalReservedSpace + reservedSpace <= storageSpace(), \"Not enough memory in the Filestorage\");\n        reservedStorageSpace[userAddress] = reservedSpace;\n        totalReservedSpace += reservedSpace;\n    }\n\n    function setVersion(string calldata newVersion) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Caller is not the admin\");\n        version = newVersion;\n    }\n\n    function createDirectory(string calldata directoryPath) external {\n        address owner = msg.sender;\n        uint directoryFsSize = Utils.calculateDirectorySize();\n        require(directoryFsSize + occupiedStorageSpace[owner] <= reservedStorageSpace[owner], \"Not enough reserved space\");\n        require(bytes(directoryPath).length > 0, \"Invalid path\");\n        string[] memory dirs = Utils.parseDirectoryPath(directoryPath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            require(currentDirectory.contentIndexes[dirs[i - 1]] > EMPTY_INDEX, \"Invalid path\");\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        require(currentDirectory.contents.length < getMaxContentCount(), \"Directory is full\");\n        string memory newDir = (dirs.length > 1) ? dirs[dirs.length - 1] : directoryPath;\n        require(currentDirectory.contentIndexes[newDir] == EMPTY_INDEX, \"File or directory exists\");\n        require(Utils.checkContentName(newDir), \"Invalid directory name\");\n        bool success = PrecompiledCaller.createDirectory(owner, directoryPath);\n        require(success, \"Directory not created\");\n        ContentInfo memory directoryInfo = ContentInfo({\n            name: newDir,\n            isFile: false,\n            size: 0,\n            status: FileStatus.NONEXISTENT,\n            isChunkUploaded: new bool[](0)\n        });\n        currentDirectory.contents.push(directoryInfo);\n        currentDirectory.contentIndexes[newDir] = currentDirectory.contents.length;\n        occupiedStorageSpace[owner] += directoryFsSize;\n    }\n\n    // TODO: delete dir with all content in it\n    function deleteDirectory(string calldata directoryPath) external {\n        address owner = msg.sender;\n        string[] memory dirs = Utils.parseDirectoryPath(directoryPath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            require(currentDirectory.contentIndexes[dirs[i - 1]] > EMPTY_INDEX, \"Invalid path\");\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        string memory targetDirectory = (dirs.length > 1) ? dirs[dirs.length - 1] : directoryPath;\n        require(currentDirectory.contentIndexes[targetDirectory] > EMPTY_INDEX, \"Invalid path\");\n        require(currentDirectory.directories[targetDirectory].contents.length == 0, \"Directory is not empty\");\n        require(!currentDirectory.contentDetails[targetDirectory].isImmutable, \"Directory is immutable\");\n        bool success = PrecompiledCaller.deleteDirectory(owner, directoryPath);\n        require(success, \"Directory is not deleted\");\n        ContentInfo memory lastContent = currentDirectory.contents[currentDirectory.contents.length - 1];\n        currentDirectory.contents[currentDirectory.contentIndexes[targetDirectory] - 1] = lastContent;\n        currentDirectory.contentIndexes[lastContent.name] = currentDirectory.contentIndexes[targetDirectory];\n        currentDirectory.contentIndexes[targetDirectory] = EMPTY_INDEX;\n        currentDirectory.contents.pop();\n        // slither-disable-next-line mapping-deletion\n        delete currentDirectory.directories[targetDirectory];\n        occupiedStorageSpace[owner] -= Utils.calculateDirectorySize();\n    }\n\n    function startUpload(string calldata filePath, uint256 fileSize) external {\n        address owner = msg.sender;\n        uint realFileSize = Utils.calculateFileSize(fileSize);\n        require(fileSize <= MAX_FILESIZE, \"File should be less than 100 MB\");\n        require(realFileSize + occupiedStorageSpace[owner] <= reservedStorageSpace[owner], \"Not enough reserved space\");\n        string[] memory dirs = Utils.parseDirectoryPath(filePath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            require(currentDirectory.contentIndexes[dirs[i - 1]] > EMPTY_INDEX, \"Invalid path\");\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        require(currentDirectory.contents.length < getMaxContentCount(), \"Directory is full\");\n        string memory pureFileName = (dirs.length > 1) ?  dirs[dirs.length - 1] : filePath;\n        require(currentDirectory.contentIndexes[pureFileName] == EMPTY_INDEX, \"File or directory exists\");\n        require(Utils.checkContentName(pureFileName), \"Invalid filename\");\n        bool success = PrecompiledCaller.startUpload(owner, filePath, fileSize);\n        require(success, \"File not created\");\n        bool[] memory isChunkUploaded = new bool[]((fileSize + getMaxChunkSize() - 1) / getMaxChunkSize());\n        currentDirectory.contents.push(ContentInfo({\n            name : pureFileName,\n            isFile : true,\n            size : fileSize,\n            status : FileStatus.UPLOADING,\n            isChunkUploaded : isChunkUploaded\n        }));\n        currentDirectory.contentIndexes[pureFileName] = currentDirectory.contents.length;\n        occupiedStorageSpace[owner] += realFileSize;\n    }\n\n    function uploadChunk(string calldata filePath, uint position, bytes calldata data) external {\n        address owner = msg.sender;\n        (ContentInfo storage file,) = getContentInfo(owner, filePath);\n        require(file.status == FileStatus.UPLOADING, \"File not found\");\n        require(position % getMaxChunkSize() == 0 && position < file.size, \"Incorrect chunk position\");\n        require(\n            file.size - position < getMaxChunkSize() &&\n            data.length == file.size - position ||\n            data.length == getMaxChunkSize(), \"Incorrect chunk length\"\n        );\n        require(!file.isChunkUploaded[position / getMaxChunkSize()], \"Chunk is already uploaded\");\n        bool success = PrecompiledCaller.uploadChunk(\n            owner,\n            filePath,\n            position,\n            data\n        );\n        require(success, \"Chunk wasn't uploaded\");\n        file.isChunkUploaded[position / getMaxChunkSize()] = true;\n    }\n\n    function finishUpload(string calldata filePath) external {\n        address owner = msg.sender;\n        (ContentInfo storage file,) = getContentInfo(owner, filePath);\n        require(file.status == FileStatus.UPLOADING, \"File not found\");\n        bool isFileUploaded = true;\n        uint chunkCount = file.isChunkUploaded.length;\n        for (uint i = 0; i < chunkCount; ++i) {\n            if (!file.isChunkUploaded[i]) {\n                isFileUploaded = false;\n            }\n        }\n        require(isFileUploaded, \"File hasn't been uploaded correctly\");\n        file.status = FileStatus.COMPLETED;\n        bool success = PrecompiledCaller.calculateFileHash(owner, filePath);\n        require(success, \"Hash hasn't been calculated\");\n    }\n\n    function deleteFile(string calldata filePath) external {\n        address owner = msg.sender;\n        (ContentInfo memory file, DetailedInfo memory details) = getContentInfo(owner, filePath);\n        require(file.status != FileStatus.NONEXISTENT, \"File not exists\");\n        require(!details.isImmutable, \"File is immutable\");\n        bool success = PrecompiledCaller.deleteFile(owner, filePath);\n        require(success, \"File not deleted\");\n        string[] memory dirs = Utils.parseDirectoryPath(filePath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        uint idx = currentDirectory.contentIndexes[file.name] - 1;\n        ContentInfo memory lastContent = currentDirectory.contents[currentDirectory.contents.length - 1];\n        currentDirectory.contents[idx] = lastContent;\n        currentDirectory.contents.pop();\n        currentDirectory.contentIndexes[lastContent.name] = currentDirectory.contentIndexes[file.name];\n        currentDirectory.contentIndexes[file.name] = EMPTY_INDEX;\n        occupiedStorageSpace[owner] -= Utils.calculateFileSize(file.size);\n    }\n\n    function setImmutable(string calldata contentPath) external {\n        address owner = msg.sender;\n        (,DetailedInfo storage content) = getContentInfo(owner, contentPath);\n        require(!content.isImmutable, \"Content is already immutable\");\n        content.isImmutable = true;\n    }\n\n    function readChunk(string calldata storagePath, uint position, uint length)\n        external\n        view\n        returns (bytes32[MAX_BLOCK_COUNT] memory chunk)\n    {\n        (address owner, string memory filePath) = Utils.parseStoragePath(storagePath);\n        (ContentInfo memory file,) = getContentInfo(owner, filePath);\n        require(file.status == FileStatus.COMPLETED, \"File hasn't been uploaded\");\n        require(length <= getMaxChunkSize() && length > 0, \"Incorrect chunk length\");\n        require(position + length <= file.size, \"Incorrect chunk position\");\n        bool success;\n        (success, chunk) = PrecompiledCaller.readChunk(\n            owner,\n            filePath,\n            position,\n            length\n        );\n        require(success, \"Chunk wasn't read\");\n    }\n\n    // TODO: handle root dir\n    function listDirectory(string calldata storagePath) external view returns (ContentInfo[] memory) {\n        (address owner, string memory directoryPath) = Utils.parseStoragePath(storagePath);\n        string[] memory dirs = Utils.parseDirectoryPath(directoryPath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 0; i < dirs.length; ++i) {\n            require(currentDirectory.contentIndexes[dirs[i]] > EMPTY_INDEX, \"Invalid path\");\n            currentDirectory = currentDirectory.directories[dirs[i]];\n        }\n        return currentDirectory.contents;\n    }\n\n    function getFileStatus(string calldata storagePath) external view returns (FileStatus) {\n        (address owner, string memory filePath) = Utils.parseStoragePath(storagePath);\n        string[] memory dirs = Utils.parseDirectoryPath(filePath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            if (currentDirectory.contentIndexes[dirs[i - 1]] == EMPTY_INDEX) {\n                return FileStatus.NONEXISTENT;\n            }\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        string memory contentName = (dirs.length > 1) ? dirs[dirs.length - 1] : filePath;\n        if (currentDirectory.contentIndexes[contentName] == EMPTY_INDEX) {\n            return FileStatus.NONEXISTENT;\n        }\n        ContentInfo memory file = currentDirectory.contents[currentDirectory.contentIndexes[contentName] - 1];\n        return file.status;\n    }\n\n    function getFileSize(string calldata storagePath) external view returns (uint fileSize) {\n        (address owner, string memory filePath) = Utils.parseStoragePath(storagePath);\n        (ContentInfo memory file,) = getContentInfo(owner, filePath);\n        require(\n            file.status == FileStatus.UPLOADING ||\n            file.status == FileStatus.COMPLETED, \"File not found\"\n        );\n        bool success;\n        (success, fileSize) = PrecompiledCaller.getFileSize(owner, filePath);\n        require(success, \"EVM error in getFileSize\");\n    }\n\n    function isImmutable(string calldata storagePath) external view returns (bool) {\n        (address owner, string memory contentPath) = Utils.parseStoragePath(storagePath);\n        (,DetailedInfo memory content) = getContentInfo(owner, contentPath);\n        return content.isImmutable;\n    }\n\n    function getTotalStorageSpace() external view returns (uint) {\n        return storageSpace();\n    }\n\n    function getTotalReservedSpace() external view returns (uint) {\n        return totalReservedSpace;\n    }\n\n    function getReservedSpace(address owner) external view returns (uint) {\n        return reservedStorageSpace[owner];\n    }\n\n    function getOccupiedSpace(address owner) external view returns (uint) {\n        return occupiedStorageSpace[owner];\n    }\n\n    function getMaxContentCount() public virtual view returns (uint) {\n        return MAX_CONTENT_COUNT;\n    }\n\n    function getMaxChunkSize() public virtual view returns (uint) {\n        return MAX_CHUNK_SIZE;\n    }\n\n    function getContentInfo(address owner, string memory contentPath) internal view returns (ContentInfo storage, DetailedInfo storage) {\n        string[] memory dirs = Utils.parseDirectoryPath(contentPath);\n        Directory storage currentDirectory = rootDirectories[owner];\n        for (uint i = 1; i < dirs.length; ++i) {\n            require(currentDirectory.contentIndexes[dirs[i - 1]] > EMPTY_INDEX, \"Invalid path\");\n            currentDirectory = currentDirectory.directories[dirs[i - 1]];\n        }\n        string memory contentName = (dirs.length > 1) ? dirs[dirs.length - 1] : contentPath;\n        require(currentDirectory.contentIndexes[contentName] > EMPTY_INDEX, \"Invalid path\");\n        ContentInfo storage contentInfo = currentDirectory.contents[currentDirectory.contentIndexes[contentName] - 1];\n        DetailedInfo storage detailedInfo = currentDirectory.contentDetails[contentName];\n        return (contentInfo, detailedInfo);\n    }\n\n    function storageSpace() internal view returns (uint) {\n        return StorageSlotUpgradeable.getUint256Slot(STORAGE_SPACE_SLOT).value;\n    }\n}\n"
            },
            "contracts/Migrations.sol": {
                "content": "pragma solidity ^0.8.9;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}"
            },
            "contracts/PrecompiledCaller.sol": {
                "content": "/*\n    PrecompiledCaller.sol - SKALE FileStorage\n    Copyright (C) 2018-Present SKALE Labs\n    @author Dmytro Nazarenko\n\n    FileStorage is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    FileStorage is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with FileStorage.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.8.9;\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n\nlibrary PrecompiledCaller {\n    using MathUpgradeable for uint;\n\n    uint constant MAX_BLOCK_COUNT = 2 ** 15;\n    uint constant FREE_MEM_PTR = 0x40;\n    uint constant READ_CHUNK_ADDRESS = 0x0A;\n    uint constant CREATE_FILE_ADDRESS = 0x0B;\n    uint constant UPLOAD_CHUNK_ADDRESS = 0x0C;\n    uint constant GET_FILE_SIZE_ADDRESS = 0x0D;\n    uint constant DELETE_FILE_ADDRESS = 0x0E;\n    uint constant CREATE_DIRECTORY_ADDRESS = 0x0F;\n    uint constant DELETE_DIRECTORY_ADDRESS = 0x10;\n    uint constant CALCULATE_FILE_HASH = 0x11;\n\n    function createDirectory(address owner, string memory directoryPath) internal returns (bool success) {\n        uint blocks = bytes(directoryPath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(directoryPath, mul(32, i))))\n            }\n            success := call(not(0), CREATE_DIRECTORY_ADDRESS, 0, p, add(64, mul(blocks, 32)), p, 32)\n        }\n    }\n\n    function deleteDirectory(address owner, string memory directoryPath) internal returns (bool success) {\n        uint blocks = bytes(directoryPath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(directoryPath, mul(32, i))))\n            }\n            success := call(not(0), DELETE_DIRECTORY_ADDRESS, 0, p, add(64, mul(blocks, 32)), p, 32)\n        }\n    }\n\n    function startUpload(address owner, string memory filePath, uint256 fileSize) internal returns (bool success) {\n        uint blocks = bytes(filePath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            mstore(add(ptr, mul(blocks, 32)), fileSize)\n            success := call(not(0), CREATE_FILE_ADDRESS, 0, p, add(64, mul(blocks, 32)), p, 32)\n        }\n    }\n\n    function uploadChunk(\n        address owner,\n        string memory filePath,\n        uint position,\n        bytes memory data\n    )\n        internal\n        returns (bool success)\n    {\n        uint dataBlocks = data.length.ceilDiv(32) + 1;\n        uint filePathBlocks = bytes(filePath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, filePathBlocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            mstore(add(ptr, mul(32, filePathBlocks)), position)\n            for {let i := 0} lt(i, dataBlocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, add(add(1, filePathBlocks), i))), mload(add(data, mul(32, i))))\n            }\n            success := call(not(0), UPLOAD_CHUNK_ADDRESS, 0, p, add(96, mul(32, add(dataBlocks, filePathBlocks))), p, 32)\n        }\n    }\n\n    function calculateFileHash(address owner, string memory filePath) internal returns (bool success) {\n        uint blocks = bytes(filePath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            success := call(not(0), CALCULATE_FILE_HASH, 0, p, add(64, mul(blocks, 32)), p, 32)\n        }\n    }\n\n    function deleteFile(address owner, string memory filePath) internal returns (bool success) {\n        uint blocks = bytes(filePath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            success := call(not(0), DELETE_FILE_ADDRESS, 0, p, add(64, mul(blocks, 32)), p, 32)\n        }\n    }\n\n    function readChunk(\n        address owner,\n        string memory filePath,\n        uint position,\n        uint length\n    )\n        internal\n        view\n        returns (bool success, bytes32[MAX_BLOCK_COUNT] memory chunk)\n    {\n        uint filePathBlocks = bytes(filePath).length.ceilDiv(32) + 1;\n        uint returnedDataBlocks = length.ceilDiv(32);\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, filePathBlocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            let p_position := add(ptr, mul(32, filePathBlocks))\n            mstore(p_position, position)\n            mstore(add(32, p_position), length)\n            success := staticcall(not(0), READ_CHUNK_ADDRESS, p, mul(32, add(3, filePathBlocks)), chunk, mul(32, returnedDataBlocks))\n        }\n    }\n\n    function getFileSize(address owner, string memory filePath)\n        internal\n        view\n        returns (bool success, uint fileSize)\n    {\n        uint blocks = bytes(filePath).length.ceilDiv(32) + 1;\n        assembly {\n            let p := mload(FREE_MEM_PTR)\n            mstore(p, owner)\n            let ptr := add(p, 32)\n            for {let i := 0} lt(i, blocks) {i := add(1, i)} {\n                mstore(add(ptr, mul(32, i)), mload(add(filePath, mul(32, i))))\n            }\n            success := staticcall(not(0), GET_FILE_SIZE_ADDRESS, p, add(32, mul(blocks, 32)), p, 32)\n            fileSize := mload(p)\n        }\n    }\n}\n"
            },
            "contracts/test/FileStorageTest.sol": {
                "content": "pragma solidity ^0.8.9;\nimport \"../FileStorage.sol\";\n\n\ncontract FileStorageTest is FileStorage {\n    uint internal maxContentCount = MAX_CONTENT_COUNT;\n    uint internal maxChunkSize = MAX_CHUNK_SIZE;\n\n    constructor() public {\n        maxContentCount = 2 ** 13;\n        maxChunkSize = 2 ** 10;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        version = \"1.0.0\";\n    }\n\n    function reserveSpaceStub(address userAddress, uint reservedSpace) external {\n        reservedStorageSpace[userAddress] = reservedSpace;\n    }\n\n    function setStorageSpace(uint newStorageSpace) external {\n        StorageSlotUpgradeable.getUint256Slot(STORAGE_SPACE_SLOT).value = newStorageSpace;\n    }\n\n    function setContentCount(uint contentCount) external {\n        maxContentCount = contentCount;\n    }\n\n    function setChunkSize(uint chunkSize) external {\n        maxChunkSize = chunkSize;\n    }\n\n    function getContentCount() external view returns (uint) {\n        return maxContentCount;\n    }\n\n    function getMaxContentCount() public override view returns (uint) {\n        return maxContentCount;\n    }\n\n    function getMaxChunkSize() public override view returns (uint) {\n        return maxChunkSize;\n    }\n}\n"
            },
            "contracts/thirdparty/strings.sol": {
                "content": "/*\n * @title String & slice utility library for Solidity contracts.\n * @author Nick Johnson <arachnid@notdot.net>\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a 'slice'. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first '.',\n *      modifying s to only contain the remainder of the string after the '.'.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n\npragma solidity ^0.8.9;\n\nlibrary strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n\n    function memcpy(uint dest, uint src, uint dataLength) private pure {\n        // Copy word-length chunks while possible\n        for(; dataLength >= 32; dataLength -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = dataLength == 0 ? type(uint256).max : 256 ** (32 - dataLength) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string memory self) internal pure returns (slice memory) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the length of a null-terminated bytes32 string.\n     * @param self The value to find the length of.\n     * @return The length of the string, from 0 to 32.\n     */\n    function len(bytes32 self) internal pure returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (uint(self) & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (uint(self) & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (uint(self) & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (uint(self) & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (uint(self) & 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }\n\n    /*\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n     *      null-terminated utf-8 string.\n     * @param self The bytes32 value to convert to a slice.\n     * @return A new slice containing the value of the input argument up to the\n     *         first null.\n     */\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }\n\n    /*\n     * @dev Returns a new slice containing the same data as the current slice.\n     * @param self The slice to copy.\n     * @return A new slice containing the same data as `self`.\n     */\n    function copy(slice memory self) internal pure returns (slice memory) {\n        return slice(self._len, self._ptr);\n    }\n\n    /*\n     * @dev Copies a slice to a new string.\n     * @param self The slice to copy.\n     * @return A newly allocated string containing the slice's text.\n     */\n    function toString(slice memory self) internal pure returns (string memory) {\n        string memory ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }\n\n    /*\n     * @dev Returns the length in runes of the slice. Note that this operation\n     *      takes time proportional to the length of the slice; avoid using it\n     *      in loops, and call `slice.empty()` if you only need to know whether\n     *      the slice is empty or not.\n     * @param self The slice to operate on.\n     * @return The length of the slice in runes.\n     */\n    function len(slice memory self) internal pure returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        uint ptr = self._ptr - 31;\n        uint end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice memory self) internal pure returns (bool) {\n        return self._len == 0;\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two slices are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first slice to compare.\n     * @param other The second slice to compare.\n     * @return The result of the comparison.\n     */\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        uint selfptr = self._ptr;\n        uint otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask = type(uint256).max; // 0xffff...\n                if(shortest < 32) {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }\n\n    /*\n     * @dev Returns true if the two slices contain the same text.\n     * @param self The first slice to compare.\n     * @param self The second slice to compare.\n     * @return True if the slices are equal, false otherwise.\n     */\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n        return compare(self, other) == 0;\n    }\n\n    /*\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n     *      slice to point to the next rune and returning `self`.\n     * @param self The slice to operate on.\n     * @param rune The slice that will contain the first rune.\n     * @return `rune`.\n     */\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint l;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            l = 1;\n        } else if(b < 0xE0) {\n            l = 2;\n        } else if(b < 0xF0) {\n            l = 3;\n        } else {\n            l = 4;\n        }\n\n        // Check for truncated codepoints\n        if (l > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += l;\n        self._len -= l;\n        rune._len = l;\n        return rune;\n    }\n\n    /*\n     * @dev Returns the first rune in the slice, advancing the slice to point\n     *      to the next rune.\n     * @param self The slice to operate on.\n     * @return A slice containing only the first rune from `self`.\n     */\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n        nextRune(self, ret);\n    }\n\n    /*\n     * @dev Returns the number of the first codepoint in the slice.\n     * @param self The slice to operate on.\n     * @return The number of the first codepoint in the slice.\n     */\n    function ord(slice memory self) internal pure returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        uint b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if `self` starts with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }\n\n    /*\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }\n\n    /*\n     * @dev Returns true if the slice ends with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }\n\n    /*\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n     *      end of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }\n\n    // Returns the memory address of the first byte of the first occurrence of\n    // `needle` in `self`, or the first byte after `self` if not found.\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr = selfptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                uint end = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr >= end)\n                        return selfptr + selflen;\n                    ptr++;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }\n\n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                ptr = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr <= selfptr)\n                        return selfptr;\n                    ptr--;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr + needlelen;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n\n    /*\n     * @dev Modifies `self` to contain everything from the first occurrence of\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n     *      if `needle` is not found.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }\n\n    /*\n     * @dev Modifies `self` to contain the part of the string from the start of\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n     *      is not found, `self` is set to the empty slice.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and `token` to everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and returning everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` up to the first occurrence of `delim`.\n     */\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        split(self, needle, token);\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and returning everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` after the last occurrence of `delim`.\n     */\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        rsplit(self, needle, token);\n    }\n\n    /*\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return The number of occurrences of `needle` found in `self`.\n     */\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }\n\n    /*\n     * @dev Returns True if `self` contains `needle`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return True if `needle` is found in `self`, false otherwise.\n     */\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }\n\n    /*\n     * @dev Returns a newly allocated string containing the concatenation of\n     *      `self` and `other`.\n     * @param self The first slice to concatenate.\n     * @param other The second slice to concatenate.\n     * @return The concatenation of the two strings.\n     */\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n        string memory ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }\n\n    /*\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n     *      newly allocated string.\n     * @param self The delimiter to use.\n     * @param parts A list of slices to join.\n     * @return A newly allocated string containing all the slices in `parts`,\n     *         joined with `self`.\n     */\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        string memory ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(uint i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }\n}\n"
            },
            "contracts/Utils.sol": {
                "content": "/*\n    Utils.sol - SKALE FileStorage\n    Copyright (C) 2018-Present SKALE Labs\n    @author Dmytro Nazarenko\n\n    FileStorage is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    FileStorage is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with FileStorage.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.8.9;\n\nimport \"./thirdparty/strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n\nlibrary Utils {\n\n    using strings for *;\n    using MathUpgradeable for uint;\n\n    uint constant MAX_FILENAME_LENGTH = 255;\n    uint constant FILESYSTEM_BLOCK_SIZE = 2 ** 12;\n\n    function checkContentName(string memory contentName) internal pure returns (bool) {\n        if (keccak256(abi.encodePacked(contentName)) == keccak256(abi.encodePacked(\"..\")) ||\n        keccak256(abi.encodePacked(contentName)) == keccak256(abi.encodePacked(\".\")) ||\n        keccak256(abi.encodePacked(contentName)) == keccak256(abi.encodePacked(\"./\")) ||\n        keccak256(abi.encodePacked(contentName)) == keccak256(abi.encodePacked(\"../\")) ||\n        keccak256(abi.encodePacked(contentName)) == keccak256(abi.encodePacked(\"/\")) ||\n        bytes(contentName).length == 0) {\n            return false;\n        }\n        uint nameLength = bytes(contentName).length;\n        if (nameLength > MAX_FILENAME_LENGTH) {\n            return false;\n        }\n        return true;\n    }\n\n    function parseDirectoryPath(string memory directoryPath) internal pure returns (string[] memory decreasePart) {\n        strings.slice memory pathSlice = directoryPath.toSlice();\n        strings.slice memory delimiter = string(\"/\").toSlice();\n        string[] memory parts = new string[](pathSlice.count(delimiter) + 1);\n        for (uint i = 0; i < parts.length; i++) {\n            parts[i] = pathSlice.split(delimiter).toString();\n        }\n        if (bytes(parts[parts.length - 1]).length == 0) {\n            delete parts[parts.length - 1];\n            decreasePart = new string[](parts.length - 1);\n\n        } else {\n            decreasePart = new string[](parts.length);\n        }\n        for (uint i = 0; i < decreasePart.length; i++) {\n            decreasePart[i] = parts[i];\n        }\n    }\n\n    function parseStoragePath(string memory storagePath) internal pure returns (address owner, string memory filePath) {\n        uint addressLength = 40;\n        require(bytes(storagePath).length > addressLength, \"Invalid storagePath\");\n        bytes memory ownerAddress = new bytes(addressLength);\n        for (uint i = 0; i < addressLength; i++) {\n            ownerAddress[i] = bytes(storagePath)[i];\n        }\n        uint160 result = 0;\n        for (uint i = 0; i < addressLength; i++) {\n            uint c = uint160(uint8(ownerAddress[i]));\n            require((c >= 48 && c <= 57) || (c >= 65 && c <= 90) || (c >= 97 && c <= 102), \"Invalid storagePath\");\n            if (c >= 48 && c <= 57) {\n                result = result * 16 + uint160(c - 48);\n            }\n            if (c >= 65 && c <= 90) {\n                result = result * 16 + uint160(c - 55);\n            }\n            if (c >= 97 && c <= 102) {\n                result = result * 16 + uint160(c - 87);\n            }\n        }\n        owner = address(result);\n        require(bytes(storagePath)[addressLength] == \"/\", \"Invalid storagePath\");\n        uint fileNameLength = bytes(storagePath).length - addressLength - 1;\n        filePath = new string(fileNameLength);\n        for (uint i = 0; i < fileNameLength; i++) {\n            bytes1 char = bytes(storagePath)[i + addressLength + 1];\n            bytes(filePath)[i] = char;\n        }\n    }\n\n    function calculateFileSize(uint size) internal pure returns (uint) {\n        if (size == 0) {\n            return FILESYSTEM_BLOCK_SIZE;\n        }\n        return size.ceilDiv(FILESYSTEM_BLOCK_SIZE) * FILESYSTEM_BLOCK_SIZE;\n    }\n\n    function calculateDirectorySize() internal pure returns (uint) {\n        return FILESYSTEM_BLOCK_SIZE;\n    }\n}\n"
            }
        },
        "settings": {
            "optimizer": {
                "enabled": false,
                "runs": 200
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "evm.bytecode",
                        "evm.deployedBytecode",
                        "evm.methodIdentifiers",
                        "metadata"
                    ],
                    "": [
                        "ast"
                    ]
                }
            }
        }
    }
}