from typing import Any, ClassVar, Iterable, Iterator, List, Optional, Tuple, Union

from typing import overload

class ADPTWArcData:
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...

class ADPTWVertexData:
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...

class AdaptiveLargeNeighborhood:
    def __init__(self, arg0: Random, arg1: float) -> None: ...
    def adapt_operator_weights(self) -> None: ...
    def add_destroy_operator(self, arg0: DestroyOperator) -> DestroyOperator: ...
    def add_repair_operator(self, arg0: RepairOperator) -> RepairOperator: ...
    def collect_score(self, arg0: DestroyOperator, arg1: RepairOperator, arg2: float) -> None: ...
    def generate(self, arg0: Evaluation, arg1: Solution, arg2: int) -> Tuple[DestroyOperator,RepairOperator]: ...
    def remove_destroy_operator(self, arg0: DestroyOperator) -> None: ...
    def remove_repair_operator(self, arg0: RepairOperator) -> None: ...
    def reset_operator_weights(self) -> None: ...
    @property
    def destroy_operators(self) -> Iterator: ...
    @property
    def repair_operators(self) -> Iterator: ...

class Arc:
    def __init__(self, arg0: object) -> None: ...

class ArcSet:
    def __init__(self, arg0: int) -> None: ...
    def forbid_arc(self, arg0: int, arg1: int) -> None: ...
    def include_arc(self, arg0: int, arg1: int) -> None: ...
    def includes_arc(self, arg0: int, arg1: int) -> bool: ...

class DestroyOperator:
    def __init__(self) -> None: ...
    def apply(self, arg0: Evaluation, arg1: Solution, arg2: int) -> List[int]: ...
    def can_apply_to(self, arg0: Solution) -> bool: ...
    def name(self) -> str: ...

class Evaluation:
    def __init__(self, *args, **kwargs) -> None: ...

class FRVCP:
    def __init__(self, arg0: Instance, arg1: Propagator) -> None: ...
    def optimize(self, arg0: List[int]) -> List[int]: ...

class GeneratorArc:
    def __init__(self, arg0, arg1: int, arg2: int, arg3: int, arg4: int) -> None: ...
    @property
    def origin_node(self) -> Any: ...
    @property
    def origin_route(self) -> Any: ...
    @property
    def target_node(self) -> Any: ...
    @property
    def target_route(self) -> Any: ...

class InsertStationOperator(Operator):
    def __init__(self, arg0: Instance) -> None: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class InsertionCache:
    def __init__(self, arg0) -> None: ...
    def clear(self) -> None: ...
    def get_best_insertions_for_vertex(self, arg0: int) -> List[InsertionMove]: ...
    def invalidate_route(self, arg0, arg1: int) -> None: ...
    def rebuild(self, arg0, arg1, arg2: List[int]) -> None: ...
    def stop_tracking(self, arg0: int) -> None: ...
    def tracks_vertex(self, arg0: int) -> bool: ...
    @property
    def moves_in_order(self) -> List[InsertionMove]: ...
    @property
    def tracked_vertices(self) -> List[int]: ...

class InsertionMove:
    __hash__: ClassVar[None] = ...
    after_node: Any
    delta_cost: float
    vertex_id: int
    def __init__(self, arg0: int, arg1, arg2: float) -> None: ...
    def __eq__(self, arg0: InsertionMove) -> bool: ...

class Instance:
    def __init__(self, arg0: List[Vertex], arg1: List[List[Arc]], arg2: int) -> None: ...
    def get_arc(self, arg0: int, arg1: int) -> Arc: ...
    def get_customer(self, arg0: int) -> Vertex: ...
    def get_station(self, arg0: int) -> Vertex: ...
    def get_vertex(self, arg0: int) -> Vertex: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @property
    def customers(self) -> Iterator: ...
    @property
    def depot(self) -> Vertex: ...
    @property
    def fleet_size(self) -> int: ...
    @property
    def number_of_customers(self) -> int: ...
    @property
    def number_of_stations(self) -> int: ...
    @property
    def number_of_vertices(self) -> int: ...
    @property
    def stations(self) -> Iterator: ...

class InterRouteTwoOptMove(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class InterRouteTwoOptOperator(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class LocalSearch:
    def __init__(self, arg0: Instance, arg1: Evaluation, arg2: Evaluation) -> None: ...
    def optimize(self, arg0, arg1) -> None: ...
    def set_use_best_improvement(self, arg0: bool) -> None: ...

class Move:
    def __init__(self) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class Node:
    def __init__(self, arg0: Vertex, arg1: object, arg2: object) -> None: ...
    def cost(self, arg0: Evaluation) -> float: ...
    def cost_components(self, arg0: Evaluation) -> List[float]: ...
    def feasible(self, arg0: Evaluation) -> bool: ...
    def update_backward(self, arg0: Evaluation, arg1: Node, arg2: Arc) -> None: ...
    def update_forward(self, arg0: Evaluation, arg1: Node, arg2: Arc) -> None: ...
    @property
    def backward_label(self) -> object: ...
    @property
    def forward_label(self) -> object: ...
    @property
    def vertex(self) -> Vertex: ...
    @property
    def vertex_id(self) -> int: ...
    @property
    def vertex_strid(self) -> str: ...

class NodeLocation:
    __hash__: ClassVar[None] = ...
    position: int
    route: int
    def __init__(self, arg0: int, arg1: int) -> None: ...
    def __eq__(self, arg0: NodeLocation) -> bool: ...
    def __getitem__(self, arg0: int) -> int: ...
    def __len__(self) -> int: ...
    def __lt__(self, arg0: NodeLocation) -> bool: ...
    def __ne__(self, arg0: NodeLocation) -> bool: ...

class Operator:
    def __init__(self) -> None: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class Propagator:
    def __init__(self) -> None: ...
    def cheaper_than(self, arg0: object, arg1: object) -> bool: ...
    def create_root_label(self) -> object: ...
    def dominates(self, arg0: object, arg1: object) -> bool: ...
    def extract_path(self, arg0: object) -> List[int]: ...
    def is_final_label(self, arg0: object) -> bool: ...
    def order_before(self, arg0: object, arg1: object) -> bool: ...
    def prepare(self, arg0: List[int]) -> None: ...
    def propagate(self, arg0: object, arg1: Vertex, arg2: Vertex, arg3: Arc) -> Optional[object]: ...

class PyConcatenationBasedEvaluation(Evaluation):
    def __init__(self) -> None: ...
    def compute_cost(self, arg0: object) -> float: ...
    def concatenate(self, arg0: object, arg1: object, arg2: Vertex) -> float: ...
    def create_backward_label(self, arg0: Vertex) -> object: ...
    def create_forward_label(self, arg0: Vertex) -> object: ...
    def is_feasible(self, arg0: object) -> bool: ...
    def propagate_backward(self, arg0: object, arg1: Vertex, arg2: Vertex, arg3: Arc) -> object: ...
    def propagate_forward(self, arg0: object, arg1: Vertex, arg2: Vertex, arg3: Arc) -> object: ...

class QuadraticNeighborhoodIterator:
    def __init__(self, *args, **kwargs) -> None: ...

class Random:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def randint(self, arg0: int, arg1: int) -> int: ...
    def uniform(self, arg0: float, arg1: float) -> float: ...

class RandomInsertionOperator(RepairOperator):
    def __init__(self, arg0: Random) -> None: ...
    def apply(self, arg0: Evaluation, arg1: Solution, arg2: List[int]) -> None: ...
    def can_apply_to(self, arg0: Solution) -> bool: ...
    def name(self) -> str: ...

class RandomRemoveOperator(DestroyOperator):
    def __init__(self, arg0: Random) -> None: ...
    def apply(self, arg0: Evaluation, arg1: Solution, arg2: int) -> List[int]: ...
    def can_apply_to(self, arg0: Solution) -> bool: ...
    def name(self) -> str: ...

class RemovalCache:
    def __init__(self, arg0) -> None: ...
    def clear(self) -> None: ...
    def invalidate_route(self, arg0, arg1: int) -> None: ...
    def rebuild(self, arg0, arg1) -> None: ...
    @property
    def moves_in_order(self) -> List[RemovalMove]: ...

class RemovalMove:
    __hash__: ClassVar[None] = ...
    delta_cost: float
    node_location: Any
    vertex_id: int
    def __init__(self, arg0: int, arg1, arg2: float) -> None: ...
    def __eq__(self, arg0: RemovalMove) -> bool: ...

class RemoveStationOperator(Operator):
    def __init__(self, arg0: Instance) -> None: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class RepairOperator:
    def __init__(self) -> None: ...
    def apply(self, arg0: Evaluation, arg1: Solution, arg2: List[int]) -> None: ...
    def can_apply_to(self, arg0: Solution) -> bool: ...
    def name(self) -> str: ...

class Route:
    __hash__: ClassVar[None] = ...
    def __init__(self, arg0: Evaluation, arg1: Instance) -> None: ...
    def exchange_segments(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: Route) -> None: ...
    def insert_segment_after(self, arg0: int, arg1: List[Node]) -> int: ...
    def insert_vertices_after(self, arg0: Iterable) -> None: ...
    def remove_segment(self, arg0: int, arg1: int) -> int: ...
    def remove_vertices(self, arg0) -> None: ...
    def update(self) -> None: ...
    def __copy__(self) -> Route: ...
    def __deepcopy__(self, arg0: dict) -> Route: ...
    def __eq__(self, arg0: Route) -> bool: ...
    def __getitem__(self, arg0: int) -> Node: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Route) -> bool: ...
    @property
    def cost(self) -> float: ...
    @property
    def cost_components(self) -> List[float]: ...
    @property
    def depot(self) -> Node: ...
    @property
    def empty(self) -> bool: ...
    @property
    def end_depot(self) -> Node: ...
    @property
    def feasible(self) -> bool: ...
    @property
    def modification_timestamp(self) -> int: ...

class RouteSegment:
    def __init__(self, arg0: Route, arg1: int, arg2: int) -> None: ...

class Solution:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self, arg0: Evaluation, arg1: Instance, arg2: int) -> None: ...
    @overload
    def __init__(self, arg0: Evaluation, arg1: Instance, arg2: List[Route]) -> None: ...
    def add_route(self, route: Optional[Route] = ...) -> None: ...
    def exchange_segment(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> None: ...
    def find(self, arg0: int) -> List[NodeLocation]: ...
    def insert_vertex_after(self, arg0: NodeLocation, arg1: int) -> int: ...
    def insert_vertices_after(self, arg0: Iterable) -> None: ...
    def lookup(self, arg0: NodeLocation) -> Node: ...
    def remove_route(self, arg0: Route) -> None: ...
    def remove_vertex(self, arg0: NodeLocation) -> None: ...
    def remove_vertices(self, arg0: List[NodeLocation]) -> None: ...
    def __copy__(self) -> Solution: ...
    def __deepcopy__(self, arg0: dict) -> Solution: ...
    def __delitem__(self, arg0: int) -> None: ...
    def __eq__(self, arg0: Solution) -> bool: ...
    def __getitem__(self, arg0: int) -> Route: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Solution) -> bool: ...
    @property
    def cost(self) -> float: ...
    @property
    def cost_components(self) -> List[float]: ...
    @property
    def feasible(self) -> bool: ...
    @property
    def insertion_points(self) -> List[NodeLocation]: ...
    @property
    def non_depot_nodes(self) -> List[NodeLocation]: ...
    @property
    def number_of_insertion_points(self) -> int: ...
    @property
    def number_of_non_depot_nodes(self) -> int: ...
    @property
    def routes(self) -> Iterator: ...

class StationInsertionMove(Move):
    def __init__(self, arg0, arg1: int) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class StationRemovalMove(Move):
    def __init__(self, arg0) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_0_1(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_0_2(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_0_3(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_1_1(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_1_2(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_1_3(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_2_1(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_2_2(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_2_3(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_3_1(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_3_2(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperatorMove_3_3(Move):
    def __init__(self, arg0, arg1) -> None: ...
    def apply(self, arg0: Instance, arg1) -> None: ...
    def get_cost_delta(self, arg0: Evaluation, arg1: Instance, arg2) -> float: ...

class SwapOperator_0_1(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_0_2(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_0_3(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_1_1(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_1_2(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_1_3(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_2_1(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_2_2(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_2_3(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_3_1(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_3_2(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class SwapOperator_3_3(Operator):
    def __init__(self, arg0: Instance, arg1: ArcSet) -> None: ...
    def create_move(self, *args, **kwargs) -> Any: ...
    def finalize_search(self) -> None: ...
    def find_next_improving_move(self, arg0: Evaluation, arg1, arg2: Move) -> Move: ...
    def prepare_search(self, arg0) -> None: ...

class Vertex:
    def __init__(self, arg0: int, arg1: str, arg2: bool, arg3: bool, arg4: object) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def is_customer(self) -> bool: ...
    @property
    def is_depot(self) -> bool: ...
    @property
    def is_station(self) -> bool: ...
    @property
    def str_id(self) -> str: ...
    @property
    def vertex_id(self) -> int: ...

def create_adptw_arc(arg0) -> Arc: ...
def create_adptw_vertex(arg0: int, arg1: str, arg2: bool, arg3: bool, arg4) -> Vertex: ...
def create_niftw_arc(arg0) -> Arc: ...
def create_niftw_vertex(arg0: int, arg1: str, arg2: bool, arg3: bool, arg4) -> Vertex: ...
def create_route(arg0: Evaluation, arg1: Instance, arg2: List[int]) -> Route: ...
def evaluate_insertion(arg0: Evaluation, arg1: Instance, arg2: Route, arg3: int, arg4: Union[int,Vertex,Node]) -> float: ...
def evaluate_splice(arg0: Evaluation, arg1: Instance, arg2: Route, arg3: int, arg4: int) -> float: ...
def iter_neighborhood(arg0) -> Iterator: ...
def sample_locations(*args, **kwargs) -> Any: ...
def sample_positions(arg0: Solution, arg1: Random, arg2: int, arg3: bool) -> List[NodeLocation]: ...
