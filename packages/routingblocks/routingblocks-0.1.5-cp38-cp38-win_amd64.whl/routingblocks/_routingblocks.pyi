class ADPTWVertexData:
    def __init__(self, x: float, y: float, demand: resource_t, earliest_time_of_arrival: resource_t,
                 latest_time_of_arrival: resource_t, service_time: resource_t) -> ADPTWVertexData:
        ...


class ADPTWArcData:
    def __init__(self, distance: resource_t, travel_time: resource_t, consumption: resource_t) -> ADPTWArcData: ...


# adptw submodule
def create_adptw_vertex(vertex_id: int, str_id: str, is_station: bool, is_depot: bool,
                        data: ADPTWVertexData) -> Vertex: ...


def create_adptw_arc(data: ADPTWArcData) -> Arc: ...


class ADPTWEvaluation(Evaluation):
    overload_penalty_factor: float
    overcharge_penalty_factor: float
    time_shift_penalty_factor: float

    def __init__(self, vehicle_battery_capacity: resource_t, vehicle_storage_capacity: resource_t) -> None: ...
class RepairOperator:
    def __init__(self) -> None: ...

    def apply(self, evaluation: Evaluation, solution: Solution, removed_vertex_ids: List[VertexID]) -> None: ...

    def can_apply_to(self, solution: Solution) -> bool: ...

    def name(self) -> str: ...


class DestroyOperator:
    def __init__(self) -> None: ...

    def apply(self, evaluation: Evaluation, solution: Solution, number_of_vertices_to_remove: int) -> List[
        VertexID]: ...

    def can_apply_to(self, solution: Solution) -> bool: ...

    def name(self) -> str: ...


class AdaptiveLargeNeighborhood:
    def __init__(self, randgen: Random, smoothing_factor: float) -> None: ...

    def adapt_operator_weights(self) -> None: ...

    def add_destroy_operator(self, destroy_operator: DestroyOperator) -> DestroyOperator: ...

    def add_repair_operator(self, repair_operator: RepairOperator) -> RepairOperator: ...

    def collect_score(self, destroy_operator: DestroyOperator, repair_operator: RepairOperator,
                      score: float) -> None: ...

    def generate(self, evaluation: Evaluation, solution: Solution, number_of_vertices_to_remove: int) -> Tuple[
        DestroyOperator, RepairOperator]: ...

    def remove_destroy_operator(self, destroy_operator: DestroyOperator) -> None: ...

    def remove_repair_operator(self, repair_operator: RepairOperator) -> None: ...

    def reset_operator_weights(self) -> None: ...

    @property
    def destroy_operators(self) -> Iterator: ...

    @property
    def repair_operators(self) -> Iterator: ...
from typing import Any


class Arc:
    def __init__(self, data: Any) -> None:
        """Creates a new arc."""
        ...

    @property
    def data(self) -> Any:
        """The arc data. Only well-defined for ArcData classes defined in Python."""
        ...
from typing import Any, List, Tuple


class Evaluation:
    def __init__(self) -> None: ...

    def compute_cost(self, label: AnyForwardLabel) -> cost_t: ...

    def evaluate(self, instance: Instance,
                 segments: List[List[Tuple[Vertex, AnyForwardLabel, AnyBackwardLabel]]]) -> cost_t: ...

    def create_backward_label(self, vertex: Vertex) -> AnyBackwardLabel: ...

    def create_forward_label(self, vertex: Vertex) -> AnyForwardLabel: ...

    def get_cost_components(self, label: AnyForwardLabel) -> List[resource_t]: ...

    def is_feasible(self, label: AnyForwardLabel) -> bool: ...

    def propagate_backward(self, pred_label: AnyForwardLabel, pred_vertex: Vertex, vertex: Vertex,
                           arc: Arc) -> AnyBackwardLabel: ...

    def propagate_forward(self, succ_label: AnyBackwardLabel, succ_vertex: Vertex, vertex: Vertex,
                          arc: Arc) -> AnyForwardLabel: ...


class PyEvaluation(Evaluation):
    ...


class PyConcatenationBasedEvaluation(Evaluation):
    def __init__(self) -> None: ...

    def concatenate(self, fwd: AnyForwardLabel, bwd: AnyBackwardLabel, vertex: Vertex) -> cost_t: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       vertex_id: VertexID) -> cost_t: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       vertex: Vertex) -> cost_t: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       node: Node) -> cost_t: ...


def evaluate_splice(evaluation: Evaluation, instance: Instance, route: Route, forward_segment_end_pos: int,
                    backward_segment_begin_pos: int) -> cost_t: ...
DPLabel = Any


class Propagator:
    def __init__(self) -> None: ...

    def cheaper_than(self, label: DPLabel, other_label: DPLabel) -> bool: ...

    def create_root_label(self) -> DPLabel: ...

    def dominates(self, label: DPLabel, other_label: DPLabel) -> bool: ...

    def extract_path(self, label: DPLabel) -> List[VertexID]: ...

    def is_final_label(self, label: DPLabel) -> bool: ...

    def order_before(self, label: DPLabel, other_label: DPLabel) -> bool: ...

    def prepare(self, route_vertex_ids: List[VertexID]) -> None: ...

    def propagate(self, label: DPLabel, origin_vertex: Vertex, target_vertex: Vertex, arc: Arc) -> Optional[
        DPLabel]: ...


class FRVCP:
    def __init__(self, instance: Instance, propagator: Propagator) -> None: ...

    def optimize(self, route_vertex_ids: List[VertexID]) -> List[VertexID]: ...
class InsertionMove:
    vertex_id: VertexID
    after_node: NodeLocation
    delta_cost: cost_t

    def __init__(self, vertex_id: VertexID, after_node_location: NodeLocation, delta_cost: cost_t) -> None: ...

    def __eq__(self, other: InsertionMove) -> bool: ...


class InsertionCache:
    def __init__(self, instance: Instance) -> None: ...

    def clear(self) -> None: ...

    def get_best_insertions_for_vertex(self, vertex_id: VertexID) -> List[InsertionMove]: ...

    def invalidate_route(self, route: Route, route_index: int) -> None: ...

    def rebuild(self, evaluation: Evaluation, solution: Solution, vertex_ids: List[VertexID]) -> None: ...

    def stop_tracking(self, vertex_id: VertexID) -> None: ...

    def tracks_vertex(self, vertex_id: VertexID) -> bool: ...

    @property
    def moves_in_order(self) -> List[InsertionMove]: ...

    @property
    def tracked_vertices(self) -> List[VertexID]: ...
from typing import Iterator, overload, List


class Instance:
    @property
    def fleet_size(self) -> int:
        """Return the number of vehicles available."""

    @property
    def number_of_customers(self) -> int:
        """Return the number of customers."""

    @property
    def number_of_stations(self) -> int:
        """Return the number of stations."""

    @property
    def number_of_vertices(self) -> int:
        """Return the number of vertices."""

    @property
    def depot(self) -> Vertex:
        """Return the depot vertex."""

    @property
    def stations(self) -> Iterator[Vertex]:
        """Return an iterator over the station vertices."""

    @property
    def customers(self) -> Iterator[Vertex]:
        """Return an iterator over the customer vertices."""

    @overload
    def __init__(self, vertices: List[Vertex], arcs: List[List[Arc]]) -> None:
        """Initialize an Instance with a list of vertices and a list of arcs. Sets the fleet size to the number of customers.
        Expects vertices to be in the order depot, stations, customers."""

    @overload
    def __init__(self, vertices: List[Vertex], arcs: List[List[Arc]], fleet_size: int) -> None:
        """Initialize an Instance with a list of vertices, a list of arcs, and a fleet size. Expects vertices to be in the
        order depot, stations, customers."""

    @overload
    def __init__(self, depot: Vertex, stations: List[Vertex], customers: List[Vertex], arcs: List[List[Arc]],
                 fleet_size: int) -> None:
        """Initialize an Instance with a depot, lists of stations and customers, a list of arcs, and a fleet size."""

    def __len__(self) -> int:
        """Return the number of vertices in the instance."""

    def __iter__(self) -> Iterator[Vertex]:
        """Return an iterator over the vertices in the instance."""

    def get_vertex(self, id: int) -> Vertex:
        """Get a vertex by its ID."""

    def get_customer(self, customer_index: int) -> Vertex:
        """Get the n-th customer vertex."""

    def get_station(self, station_index: int) -> Vertex:
        """Get the n-th station vertex."""

    def get_arc(self, source_vertex_id: int, target_vertex_id: int) -> Arc: ...
class ArcSet:
    def __init__(self, number_of_vertices: int) -> None: ...

    def forbid_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> None: ...

    def include_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> None: ...

    def includes_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> bool: ...


class GeneratorArc:
    @overload
    def __init__(self, solution: Solution, origin_route_index: int, origin_node_position: int, target_route_index: int,
                 target_node_position: int) -> None: ...

    @overload
    def __init__(self, solution: Solution, origin_location: NodeLocation, target_location: NodeLocation) -> None: ...

    @property
    def origin_node(self) -> Node: ...

    @property
    def origin_route(self) -> Route: ...

    @property
    def target_node(self) -> Node: ...

    @property
    def target_route(self) -> Route: ...


class Move:
    def __init__(self) -> None: ...

    def apply(self, instance: Instance, solution: Solution) -> None: ...

    def get_cost_delta(self, evaluation: Evaluation, instance: Instance, solution: Solution) -> float: ...


class LocalSearchOperator:
    def __init__(self) -> None: ...

    def finalize_search(self) -> None: ...

    def find_next_improving_move(self, evaluation: Evaluation, solution: Solution,
                                 last_evaluated_move: Move) -> Move: ...

    def prepare_search(self, solution: Solution) -> None: ...


class LocalSearch:
    def __init__(self, instance: Instance, evaluation: Evaluation, exact_evaluation: Optional[Evaluation]) -> None: ...

    def optimize(self, solution: Solution, operator: List[LocalSearchOperator]) -> None: ...

    def set_use_best_improvement(self, best_improvement: bool) -> None: ...


class QuadraticNeighborhoodIterator:
    def __init__(self) -> None: ...


def iter_neighborhood(solution: Solution) -> Iterator: ...
class NIFTWVertexData:
    def __init__(self, x: float, y: float, demand: resource_t, earliest_time_of_arrival: resource_t,
                 latest_time_of_arrival: resource_t, service_time: resource_t) -> None:
        ...


class NIFTWArcData:
    def __init__(self, distance: resource_t, travel_time: resource_t, consumption: resource_t) -> None:
        ...


# niftw submodule
def create_niftw_vertex(vertex_id: int, str_id: str, is_station: bool, is_depot: bool, data: NIFTWVertexData) -> Vertex:
    ...


def create_niftw_arc(data: NIFTWArcData) -> Arc: ...


class NIFTWEvaluation(Evaluation):
    overload_penalty_factor: float
    overcharge_penalty_factor: float
    time_shift_penalty_factor: float

    def __init__(self, vehicle_battery_capacity: resource_t, vehicle_storage_capacity: resource_t) -> None: ...
class Node:
    def __init__(self, vertex: Vertex, fwd_label: AnyForwardLabel, bwd_label: AnyBackwardLabel) -> None: ...

    def cost(self, evaluation: Evaluation) -> float: ...

    def cost_components(self, evaluation: Evaluation) -> List[float]: ...

    def feasible(self, evaluation: Evaluation) -> bool: ...

    def update_backward(self, evaluation: Evaluation, predecessor: Node, arc: Arc) -> None: ...

    def update_forward(self, evaluation: Evaluation, successor: Node, arc: Arc) -> None: ...

    @property
    def backward_label(self) -> AnyBackwardLabel: ...

    @property
    def forward_label(self) -> AnyForwardLabel: ...

    @property
    def vertex(self) -> Vertex: ...

    @property
    def vertex_id(self) -> int: ...

    @property
    def vertex_strid(self) -> str: ...

    def __str__(self) -> str: ...
class NodeLocation:
    route: int
    position: int

    def __init__(self, route: int, position: int) -> None: ...

    def __eq__(self, other: NodeLocation) -> bool: ...

    def __getitem__(self, i: int) -> int: ...

    def __len__(self) -> int: ...

    def __lt__(self, other: NodeLocation) -> bool: ...

    def __ne__(self, other: NodeLocation) -> bool: ...
class Random:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, seed: int) -> None: ...

    def randint(self, min: int, max: int) -> int: ...

    def uniform(self, min: float, max: float) -> float: ...


def sample_locations(solution: Solution, randgen: Random, k: int, include_first_depot: bool) -> List[NodeLocation]: ...
class RemovalMove:
    vertex_id: VertexID
    node_location: NodeLocation
    delta_cost: cost_t

    def __init__(self, vertex_id: VertexID, node_location: NodeLocation, delta_cost: cost_t) -> None: ...

    def __eq__(self, other: RemovalMove) -> bool: ...


class RemovalCache:
    def __init__(self, instance: Instance) -> None: ...

    def clear(self) -> None: ...

    def invalidate_route(self, route: Route, route_index: int) -> None: ...

    def rebuild(self, evaluation: Evaluation, solution: Solution) -> None: ...

    @property
    def moves_in_order(self) -> List[RemovalMove]: ...
from typing import ClassVar


class Route:
    def __init__(self, evaluation: Evaluation, instance: Instance) -> None: ...

    @property
    def cost(self) -> float: ...

    @property
    def cost_components(self) -> List[float]: ...

    @property
    def depot(self) -> Node: ...

    @property
    def empty(self) -> bool: ...

    @property
    def end_depot(self) -> Node: ...

    @property
    def feasible(self) -> bool: ...

    @property
    def modification_timestamp(self) -> int: ...

    def __iter__(self) -> Iterator: ...

    def __len__(self) -> int: ...

    def __eq__(self, arg0: Route) -> bool: ...

    def __ne__(self, arg0: Route) -> bool: ...

    def exchange_segments(self, segment_begin_position: int, segment_end_position: int,
                          other_segment_begin_position: int,
                          other_segment_end_position: int, other_route: Route) -> None: ...

    def insert_segment_after(self, position: int, node_segment: List[Node]) -> int: ...

    def insert_vertices_after(self, vertices: Iterable) -> None: ...

    def remove_segment(self, begin_position: int, end_position: int) -> int: ...

    def remove_vertices(self, vertex_positions: List[int]) -> None: ...

    def update(self) -> None: ...

    def __copy__(self) -> Route: ...

    def __deepcopy__(self, memodict: Dict = None) -> Route: ...

    def __getitem__(self, position: int) -> Node: ...


def create_route(evaluation: Evaluation, instance: Instance, vertex_ids: List[int]) -> Route: ...
class Solution:
    @overload
    def __init__(self, evaluation: Evaluation, instance: Instance, number_of_routes: int) -> None: ...

    @overload
    def __init__(self, evaluation: Evaluation, instance: Instance, routes: List[Route]) -> None: ...

    def add_route(self, route: Optional[Route] = None) -> None: ...

    @overload
    def exchange_segment(self, first_route: Route, first_route_begin_position: int, first_route_end_position: int,
                         second_route: Route, second_route_begin_position: int,
                         second_route_end_position: int) -> None: ...

    @overload
    def exchange_segment(self, first_route_index: int, first_route_begin_position: int, first_route_end_position: int,
                         second_route_index: int, second_route_begin_position: int,
                         second_route_end_position: int) -> None: ...

    def find(self, vertex_id: int) -> List[NodeLocation]: ...

    def insert_vertex_after(self, after_location: NodeLocation, vertex_id: int) -> int: ...

    def insert_vertices_after(self, arg0: Iterable[Tuple[VertexID, NodeLocation]]) -> None: ...

    def lookup(self, location: NodeLocation) -> Node: ...

    def remove_route(self, route: Route) -> None: ...

    def remove_vertex(self, location: NodeLocation) -> None: ...

    def remove_vertices(self, locations: List[NodeLocation]) -> None: ...

    def __copy__(self) -> Solution: ...

    def __deepcopy__(self, memodict: dict = {}) -> Solution: ...

    def __delitem__(self, route_index: int) -> None: ...

    def __eq__(self, other: Solution) -> bool: ...

    def __getitem__(self, route_index: int) -> Route: ...

    def __iter__(self) -> Iterator: ...

    def __len__(self) -> int: ...

    def __ne__(self, other: Solution) -> bool: ...

    @property
    def cost(self) -> cost_t: ...

    @property
    def cost_components(selfa) -> List[resource_t]: ...

    @property
    def feasible(self) -> bool: ...

    @property
    def insertion_points(self) -> List[NodeLocation]: ...

    @property
    def non_depot_nodes(self) -> List[NodeLocation]: ...

    @property
    def number_of_insertion_points(self) -> int: ...

    @property
    def number_of_non_depot_nodes(self) -> int: ...

    @property
    def routes(self) -> Iterator: ...
from typing import Any

resource_t = float
cost_t = float
AnyForwardLabel = Any
AnyBackwardLabel = Any
VertexID = int
from typing import Any


class Vertex:
    vertex_id: int
    str_id: str
    is_station: bool
    is_depot: bool

    def __init__(self, vertex_id: int, str_id: str, is_station: bool, is_depot: bool, data: Any) -> None:
        """Creates a new vertex."""
        ...

    @property
    def is_customer(self) -> bool:
        """Whether the vertex is a customer."""
        ...

    @property
    def data(self) -> Any:
        """The vertex data. Only well-defined for VertexData classes defined in Python."""
        ...

    def __str__(self) -> str: ...
