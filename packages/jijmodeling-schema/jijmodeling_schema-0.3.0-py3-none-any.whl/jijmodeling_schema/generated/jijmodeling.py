# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: array_length.proto, binary_op.proto, commutative_op.proto, number_lit.proto, placeholder.proto, decision_var.proto, unary_op.proto, element.proto, subscript.proto, reduction_op.proto, expression.proto, forall.proto, constraint.proto, custom_penalty_term.proto, problem.proto, header.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto


class BinaryOpKind(betterproto.Enum):
    UNKNOWN = 0
    POW = 1
    MOD = 2
    EQ = 3
    NOT_EQ = 4
    LESS_THAN = 5
    LESS_THAN_EQ = 6
    GREATER_THAN = 7
    GREATER_THAN_EQ = 8


class CommutativeOpKind(betterproto.Enum):
    UNKNOWN = 0
    ADD = 1
    MUL = 2
    MIN = 3
    MAX = 4
    AND = 5
    OR = 6
    XOR = 7


class NumberLitType(betterproto.Enum):
    FLOAT = 0
    INTEGER = 1


class DecisionVarType(betterproto.Enum):
    BINARY = 0
    INTEGER = 1
    CONTINUOUS = 2
    SEMI_INTEGER = 3
    SEMI_CONTINUOUS = 4


class UnaryOpKind(betterproto.Enum):
    UNKNOWN = 0
    ABS = 1
    CEIL = 2
    FLOOR = 3
    LOG_2 = 4
    LOG_10 = 5
    LOG_E = 6


class ReductionOpKind(betterproto.Enum):
    UNKNOWN = 0
    SUM = 1
    PROD = 2


class ConstraintEquality(betterproto.Enum):
    EQUAL = 0
    LESS_THAN_EQUAL = 1


class ProblemSense(betterproto.Enum):
    MIN = 0
    MAX = 1


@dataclass
class ArrayLength(betterproto.Message):
    array_id: str = betterproto.string_field(1)
    axis: int = betterproto.uint64_field(2)


@dataclass
class BinaryOp(betterproto.Message):
    kind: "BinaryOpKind" = betterproto.enum_field(1)
    left_id: str = betterproto.string_field(2)
    right_id: str = betterproto.string_field(3)


@dataclass
class CommutativeOp(betterproto.Message):
    kind: "CommutativeOpKind" = betterproto.enum_field(1)
    term_ids: List[str] = betterproto.string_field(2)


@dataclass
class NumberLit(betterproto.Message):
    type: "NumberLitType" = betterproto.enum_field(1)
    value: int = betterproto.uint64_field(2)


@dataclass
class Placeholder(betterproto.Message):
    name: str = betterproto.string_field(1)
    ndim: int = betterproto.uint64_field(2)


@dataclass
class DecisionVar(betterproto.Message):
    type: "DecisionVarType" = betterproto.enum_field(1)
    name: str = betterproto.string_field(2)
    ndim: int = betterproto.uint64_field(3)
    lower_bound_id: str = betterproto.string_field(4)
    upper_bound_id: str = betterproto.string_field(5)


@dataclass
class UnaryOp(betterproto.Message):
    kind: "UnaryOpKind" = betterproto.enum_field(1)
    operand_id: str = betterproto.string_field(2)


@dataclass
class Element(betterproto.Message):
    name: str = betterproto.string_field(1)
    ndim: int = betterproto.uint64_field(2)
    bound: "ElementBound" = betterproto.message_field(3, group="belong_to")
    range: "ElementRange" = betterproto.message_field(4, group="belong_to")


@dataclass
class ElementBound(betterproto.Message):
    bound_id: str = betterproto.string_field(1)


@dataclass
class ElementRange(betterproto.Message):
    start_id: str = betterproto.string_field(1)
    end_id: str = betterproto.string_field(2)


@dataclass
class Subscript(betterproto.Message):
    ndim: int = betterproto.uint64_field(1)
    subscripted_variable_id: str = betterproto.string_field(2)
    subscripts_id_list: List[str] = betterproto.string_field(3)


@dataclass
class ReductionOp(betterproto.Message):
    kind: "ReductionOpKind" = betterproto.enum_field(1)
    index_id: str = betterproto.string_field(2)
    index_condition_id: str = betterproto.string_field(3)
    operand_id: str = betterproto.string_field(4)


@dataclass
class Expression(betterproto.Message):
    id: str = betterproto.string_field(1)
    expr_node_map: Dict[str, "ExpressionKind"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class ExpressionKind(betterproto.Message):
    # No child node
    number_lit: "NumberLit" = betterproto.message_field(1, group="kind")
    placeholder: "Placeholder" = betterproto.message_field(2, group="kind")
    decision_var: "DecisionVar" = betterproto.message_field(3, group="kind")
    # One child node
    array_length: "ArrayLength" = betterproto.message_field(4, group="kind")
    unary_op: "UnaryOp" = betterproto.message_field(5, group="kind")
    # Two children nodes
    binary_op: "BinaryOp" = betterproto.message_field(6, group="kind")
    # Multiple children nodes
    commutative_op: "CommutativeOp" = betterproto.message_field(7, group="kind")
    element: "Element" = betterproto.message_field(8, group="kind")
    subscript: "Subscript" = betterproto.message_field(9, group="kind")
    reduction_op: "ReductionOp" = betterproto.message_field(10, group="kind")


@dataclass
class Forall(betterproto.Message):
    index: "Element" = betterproto.message_field(1)
    index_domain_node_map: Dict[str, "ExpressionKind"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    condition: "Expression" = betterproto.message_field(3)


@dataclass
class Constraint(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    equality: "ConstraintEquality" = betterproto.enum_field(3)
    left: "Expression" = betterproto.message_field(4)
    right: "Expression" = betterproto.message_field(5)
    forall_list: List["Forall"] = betterproto.message_field(6)


@dataclass
class CustomPenaltyTerm(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    term: "Expression" = betterproto.message_field(3)
    forall_list: List["Forall"] = betterproto.message_field(4)


@dataclass
class Problem(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    sense: "ProblemSense" = betterproto.enum_field(3)
    objective_function: "Expression" = betterproto.message_field(4)
    constraint_map: Dict[str, "Constraint"] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    custom_penalty_term_map: Dict[str, "CustomPenaltyTerm"] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class Header(betterproto.Message):
    id: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    problem: "Problem" = betterproto.message_field(3)
