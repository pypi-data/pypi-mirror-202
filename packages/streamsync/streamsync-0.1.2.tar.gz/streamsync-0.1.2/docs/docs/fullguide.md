# Getting started

## Installation and Quickstart

Getting started with Streamsync is easy. It works on Linux, Mac and Windows.

```sh
pip install streamsync
streamsync hello
```

- The first command will install Streamsync using pip.
- The second command will create a demo application in the subfolder "hello" and start Streamsync Builder, the framework's visual editor, which will be accessible via a local URL.

We recommend using a virtual environment.

## Create an app

You can use the command `streamsync create`, which will create a placeholder app in the path provided.

```sh
streamsync create [path]

# Creates a new app in folder "testapp"
streamsync create testapp
```

A Streamsync app is a folder with the following items.

- `main.py`. The entry point for the app. You can import anything you need from here.
- `ui.json`. Contains the UI component declarations. Maintained by Builder, the framework's visual editor.
- `static/`. This folder contains frontend-facing static files which you might want to distribute with your app. For example, images.

## Start the editor

You can use the command `streamsync edit`.

```sh
streamsync edit [path]

# Edit the application in subfolder "testapp"
streamsync edit testapp
```

This command will provide you with a local URL which you can use to access Builder.

::: warning Streamsync Builder shouldn't be directly exposed to the Internet.

It's not safe and it won't work, as requests from non-local origins are rejected.

If you need to access Builder remotely, we recommend setting up a SSH tunnel.
:::

## Builder basics

Streamsync Builder works as an overlay of the running app; you edit your app while it's running. This gives you an accurate representation of how the app will look like and how it'll behave, without the need to constantly preview it. Changes to the user interface are automatically saved to `ui.json`.

### Adding and moving components

- Drag and drop components from the _Toolkit_ to the app to create new components.
- Some components can be parents, e.g. _Section_. Others can't, e.g. _Text_.
- Certain components have restrictions. For example, a _Column_ can only be added to a _Column Container_. A _Sidebar_ can only be added to a _Page_.
- By default, components are added in the last position. To add components in a specific position, drag over the desired parent until the insertion lines are shown.
- You can drag and drop existing components within the app, from one parent to another, or within the same parent to reposition them.
- Alternatively, you can use the _Component Tree_ either as source or destination for drag and drop.

### Selecting a component

- Select a component by clicking on it. If you click on a component that's already selected, the click will be treated as an interaction with the app.
- Two things will happen when a component is selected:
  1. The _Component Settings_ panel will open on the right. Depending on available screen real estate, the panel will open on top of the app or next to it.
  2. A set of component-specific actions, _Component Shortcuts_, will be displayed on top of the component.

### Component settings

Settings are divided into three sections. Note that application state and event handlers are discussed in detail later on.

- _Properties_, divided into _General_ and _Style_ categories. Values can include literals, e.g. `monkey`, or references to application state, e.g. `@{my_favourite_animal}`.
- _Events_. The events generated by this component, with the option of setting event handlers for those.
- _Visibility_. Whether the component should be displayed. Note that hidden components are still part of the HTML code, but aren't shown.

Changes to settings can be undone and redone using the buttons on the top bar.

### Component shortcuts

Perform a variety of operations on existing components. Options will be grayed out when they're not applicable to the relevant component. Most shortcuts can be triggered using the keyboard; hover over them to show the appropriate combination.

- _Add_. Adds a child of a given type to this component.
- _Move up_. Decrements the position index of the component, used to sort children in the parent container.
- _Move down_. Increments the position index of the component.
- _Cut_. Cuts the component and places it into Builder's internal clipboard.
- _Copy_. Copies the component and places it into the internal clipboard.
- _Paste_. Pastes the content of the internal clipboard using the selected component as a parent.
- _Go to parent_. Selects the parent of the selected component.
- _Delete_. Deletes this component.

Just like with changes to settings, actions performed can be undone and redone using the buttons on the top bar.

### Modes

You can switch modes between _User Interface_, _Code_ and _Preview_ using the buttons on the top bar.

#### UI

It's for the UI

#### Code

Opens the code editor, built on Monaco (Visual Studio's code editor).

::: info You don't need to rely on the built-in code editor
The code editor provided by Builder is provided for convenience and is ideal for quick edits. However, you can keep using your favourite editor, plugins, etc.
:::

## Application state

Streamsync assigns each session its own application state.

### Initialising state

The initial application state can be set by calling `ss.init_state()` and passing a `Dict` as argument. **All session states will kick off as a copy of the initial state**.

```py
import streamsync as ss

ss.init_state({
    "counter": 0,
})

# Event handler
# It receives the session state as an argument and mutates it
def increment(state):
    state["counter"] += 1

```

In the example above, everyone starts with `counter` set to 0. But after users start interacting with the app and triggering event handlers, the value of `counter` will be different across sessions. Some users will trigger `increment` three times, making it 3. Some will trigger `increment` ten times, making it 10.

### Nested state elements

From Builder, nested

```py
ss.init_state({
    "counter": 0,
    "my_app": {
        "title": "Nested value"
    }
})
```

### Backend-only state elements

By default, all of the elements in the session state are sent to the frontend.

::: warning State elements are sent to the frontend by default
Even if they aren't actively being shown in the user interface, they're sent to the user's browser.
:::

Prefix a state element with `_` (underscore) to make it private (backend-only). This can be very useful in some scenarios.

- When synchronisation is not necessary. In some cases, we'll only need the data in the backend.
- When synchronisation is not possible, because the object can't be serialised / shown in the browser. For example, a database connection.
- When data is relevant to a specific session, but shouldn't be disclosed.

### Mutation detection and sync

Once the event mutation

### Using application state in the user interface

The interface presented to users will ultimately be based on two things:

1. Static content, stored in `ui.json`.
2. Application state, which will be different across sessions.

Application state can be used to set component properties. For example, if we want

## Event handlers

By default, all the functions available on `main.py` are treated as potential event handlers. Make a function private by prefixing it with `_` (underscore).

### Global variables

Since Streamsync runs the script once and keeps it in memory, using global variables is possible. Modi

## Running the app

### Run anywhere using Docker

## Summary

- An app is created with `streamsync create [path]`.
- A Streamsync app is a folder with two important files: `ui.json` and `main.py`.
- Builder is launched with `streamsync edit [path]`.
- You create the user interface, reference application state and connect event handlers using Builder. This is all saved in `ui.json` automatically.
- Components have built-in documentation accessible from the _Settings_ panel.
- You define the backend logic in `main.py`, including initial application state and event handlers
- `main.py` serves as an entry point, you can import anything you need from this file.
- You can use global variables. Keep in mind that they'll apply to all sessions.
- An app can be executed with the command `streamsync run [path]`.
- You can use Docker to deploy your app anywhere.
